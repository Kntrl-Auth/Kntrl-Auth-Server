{
  "type": "object",
  "properties": {
    "http": {
      "type": "object",
      "properties": {
        "port": {
          "type": "integer",
          "description": "A port that the server will use to accept http requests\n",
          "format": "int32",
          "minimum": -2147483648,
          "maximum": 2147483647
        },
        "bind": {
          "type": "string",
          "description": "IP address to bind to. Usually 0.0.0.0 to accept for any connection or 127.0.0.1 to accept only localhost\n"
        },
        "proxy": {
          "type": "boolean",
          "description": "If true, X-Forwarded-For header is used to get client's IP address"
        }
      },
      "description": "Http server config",
      "x-order": "578911261-1"
    },
    "logins": {
      "uniqueItems": true,
      "description": "Types of logins that can be used for identification.\n\nIf the login type is not specified in the auth config - it will be considered a simple login:\nthe user can set any name. E.g. username.\n\nIf the login type is specified in the auth config, this login will be generated by\nthe corresponding authenticator. E.g. email, phone or facebook account id.\n\n",
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      ]
    },
    "auths": {
      "type": "object",
      "additionalProperties": {
        "x-additionalPropertiesName": "auth",
        "type": "object",
        "properties": {
          "requiresAuth": {
            "description": "If this is not null, app forbids to add this auth until listed auth enabled.\n- if this a string -> require specified auth to be enabled before this.\n- array of strings -> require any of listed auths to be enabled\n- array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`",
            "x-nullable": true,
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "skipOnFail": {
            "type": "boolean",
            "description": "When this is set to true app will attempt next auth in case of error on current.\nIt's works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be\nexecuted only when IP auth is failed.\nIf set to false any error on this auth will stop the whole request execution."
          },
          "rateLimiter": {
            "type": "string",
            "description": "Apply rate limiter for this auth.",
            "x-nullable": true
          },
          "burnQuota": {
            "type": "number",
            "description": "Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified",
            "format": "double",
            "minimum": -1.7976931348623157e+308,
            "maximum": 1.7976931348623157e+308
          }
        },
        "description": "Authentication implementation config",
        "x-order": "2102313733-0"
      },
      "description": "List of auth names and auth configs\n\nTo use builtin auths (not a plugin or remote) follow the example: `\"password\": { ... }` or\n`\"anyAuthName\": { \"builtin\": \"password\", ... }`\n"
    },
    "entries": {
      "type": "object",
      "additionalProperties": {
        "x-additionalPropertiesName": "entry",
        "type": "object",
        "properties": {
          "factorsRequired": {
            "type": "object",
            "additionalProperties": {
              "description": "List of auths that could be chosen for this factor.\n",
              "x-additionalPropertiesName": "factor",
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "description": "Specifies factors that always required to be authenticated.\n\nUsually it's main auth method (e.g. password) + social login (e.g. facebook) +\nreserve auth option in case of lost/forgotten main auth credentials (e.g. secret questions or email auth).\n\nThese factors are always required even when user hasn't enabled them explicitly.\n\n"
          },
          "factorsOptional": {
            "type": "object",
            "additionalProperties": {
              "x-additionalPropertiesName": "factor",
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "description": "This factors can be skipped if user hasn't enabled them. Used for optional 2FA.\nE.g. If user added mobile phone -> use it for 2FA otherwise skip 2FA.\n"
          },
          "requiresEntry": {
            "description": "Require user to be already signed in by one of the listed entries. Usually it used for action confirmation, e.g.\n\"payment\" that requires confirmation by sms, requires user to be already signed in (e.g. with entry \"app\".",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "accessToken": {
            "description": "Override access token lifetime for sessions of this entry.",
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "ttl": {
                    "type": "string",
                    "description": "Override access token ttl",
                    "x-nullable": true
                  },
                  "cache": {
                    "type": "boolean",
                    "description": "Enable or disable client-side caching of access token",
                    "x-nullable": true
                  }
                },
                "x-order": "-842539141-1"
              }
            ]
          },
          "ttl": {
            "type": "string",
            "description": "Max lifetime of session.\n",
            "x-nullable": true
          },
          "editAccount": {
            "type": "boolean",
            "description": "Is this session allowed to add/remove new auth, enable/disable factors, etc.?"
          }
        },
        "description": "Configuration for app entry.",
        "x-order": "-842539141-0"
      },
      "description": "List of app entries. Entry usually represents UI used for signing in/up or additional authentication\nbefore action. E.g.:\n- app: main entry that requests user login/email + password and 2fa (if enabled)\n- api: entry that allows user to generate API keys and connect third-party app\n- action: additional authentication (e.g. code from sms) requested before e.g. payment\n"
    },
    "db": {
      "required": [
        "rateLimiter",
        "session",
        "user"
      ],
      "type": "object",
      "properties": {
        "user": {
          "description": "User database config",
          "allOf": [
            {
              "type": "object",
              "x-order": "-1580107990-0"
            }
          ]
        },
        "session": {
          "description": "Session database config.\n\nIf you aren't using cluster, prefer in-memory database.\n\nYou can use in-token to not use database at all. Use it with `token.access.cacheUnauthenticated = true` and\n`token.access.cache != null` values.",
          "allOf": [
            {
              "type": "object",
              "x-order": "-1580107990-0"
            }
          ]
        },
        "rateLimiter": {
          "description": "Database for rate-limiters. If you don't use rate-limiter leave this empty (`{}`).",
          "allOf": [
            {
              "type": "object",
              "x-order": "-1580107990-0"
            }
          ]
        }
      },
      "description": "Database connection configs",
      "x-order": "-1723799702-3"
    },
    "token": {
      "type": "object",
      "properties": {
        "access": {
          "type": "object",
          "properties": {
            "cookie": {
              "type": "boolean",
              "description": "Send token in `access_token` cookie"
            },
            "cache": {
              "description": "If not null - access token contains signed session data, so it's not required to request session database for\naccess check.",
              "allOf": [
                {
                  "type": "string",
                  "enum": [
                    "JWT",
                    "BINARY"
                  ]
                }
              ],
              "x-nullable": true
            },
            "cacheUnauthenticated": {
              "type": "boolean",
              "description": "By default, unauthenticated sessions can't be cached."
            },
            "ttl": {
              "type": "string",
              "description": "Lifetime for access token. 1d, 30m, etc.\n"
            }
          },
          "description": "Short-living token used for authentication.",
          "x-order": "-1195634750-1"
        },
        "refresh": {
          "type": "object",
          "properties": {
            "ttl": {
              "type": "string",
              "description": "Lifetime for refresh token. 10d, 3M, etc.\n"
            },
            "maxTtl": {
              "type": "string",
              "description": "Refresh token can be prolonged by refresh.\n"
            },
            "unauthenticatedTtl": {
              "type": "string",
              "description": "Lifetime of token for unauthenticated session. Limits time that user has to sign in/up, restoring password etc.\n"
            },
            "allowReuse": {
              "type": "boolean",
              "description": "If false - one refresh token can't be used twice. New refresh token will be provided by refresh API."
            }
          },
          "description": "Long-living token used for generation of new access token.\nTHis is optional. You can set longer access-token lifetime instead.",
          "x-order": "-1195634750-5"
        },
        "sameUserAgent": {
          "type": "boolean",
          "description": "Require all request to be made from the same device."
        }
      },
      "description": "Token lifetime config.",
      "x-order": "-1195634750-0"
    },
    "rateLimiters": {
      "type": "object",
      "additionalProperties": {
        "x-additionalPropertiesName": "rate-limiter id",
        "type": "object",
        "properties": {
          "userId": {
            "type": "boolean",
            "description": "Create different rate limiters for different users."
          },
          "ip": {
            "type": "boolean",
            "description": "Create different rate limiters for different ips."
          },
          "quota": {
            "type": "number",
            "description": "Total quota available for time period. Quota means \"weight\" of a request. So quota 1.0 and period 1s\nallows 10 request with weight 0.1 per seconds or 5 request with weight 0.2 per second.",
            "format": "double",
            "minimum": -1.7976931348623157e+308,
            "maximum": 1.7976931348623157e+308
          },
          "period": {
            "type": "string",
            "description": "Quota restoring period\n"
          },
          "alignLoad": {
            "type": "boolean",
            "description": "Insert delays between requests if there are too many simultaneous requests."
          },
          "parent": {
            "type": "string",
            "description": "Allows to combine rate limiters. Let's say rt1 allows 10 reqs per seconds, and rt2 allows 20 reqs per minute.\nIf the rt1 has the rt2 as a parent, that means that rt1 allows 10 reqs per seconds but not more than 20 per minute.",
            "x-nullable": true
          }
        },
        "description": "Rate limiter configuration",
        "x-order": "-1666811215-0"
      },
      "description": "List of rate limiters\n"
    },
    "secret": {
      "type": "string",
      "description": "The key that app uses for RSA certificate generation used for token signature.\nIf `null` - app will generate secret automatically during startup."
    },
    "healthCheckKey": {
      "type": "string",
      "description": "Set this key if you want to restrict access to the health-check.",
      "x-nullable": true
    },
    "i18n": {
      "type": "object",
      "properties": {
        "dir": {
          "type": "string",
          "description": "Directory when messages are stored. To support new language add `<lang>.json5` file. App will create helpful\ntemplates after start if dir is not null.\n",
          "x-nullable": true
        },
        "default": {
          "type": "string",
          "description": "Default language to use.\n"
        }
      },
      "description": "Configuration for localization of error messages, emails, etc.",
      "x-order": "-1723799702-4"
    },
    "$schema": {
      "type": "string"
    }
  },
  "x-order": "578911261-0",
  "$schema": "http://json-schema.org/draft-04/schema#"
}