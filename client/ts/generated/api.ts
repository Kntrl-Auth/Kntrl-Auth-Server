/* tslint:disable */
/* eslint-disable */
/**
 * Kntrl API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessDenied
 */
export interface AccessDenied {
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AccessTokenCfg
 */
export interface AccessTokenCfg {
    /**
     * 
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cookie'?: boolean;
    /**
     * 
     * @type {Cache}
     * @memberof AccessTokenCfg
     */
    'cache'?: Cache;
    /**
     * 
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cacheUnauthenticated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenCfg
     */
    'ttl'?: string;
}
/**
 * 
 * @export
 * @interface AnswerErr
 */
export interface AnswerErr {
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooLong': boolean;
}
/**
 * 
 * @export
 * @interface AnyErr
 */
export interface AnyErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AnyErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AnyErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof AnyErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AppCfg
 */
export interface AppCfg {
    /**
     * 
     * @type {HttpCfg}
     * @memberof AppCfg
     */
    'http'?: HttpCfg;
    /**
     * list of logins
     * @type {Set<string>}
     * @memberof AppCfg
     */
    'logins': Set<string>;
    /**
     * 
     * @type {{ [key: string]: AuthCfg; }}
     * @memberof AppCfg
     */
    'auths': { [key: string]: AuthCfg; };
    /**
     * 
     * @type {{ [key: string]: EntryCfg; }}
     * @memberof AppCfg
     */
    'entries': { [key: string]: EntryCfg; };
    /**
     * 
     * @type {DbsCfg}
     * @memberof AppCfg
     */
    'db': DbsCfg;
    /**
     * 
     * @type {TokenCfg}
     * @memberof AppCfg
     */
    'token'?: TokenCfg;
    /**
     * 
     * @type {{ [key: string]: RateLimiterCfg; }}
     * @memberof AppCfg
     */
    'rateLimiters'?: { [key: string]: RateLimiterCfg; };
    /**
     * 
     * @type {string}
     * @memberof AppCfg
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof AppCfg
     */
    'healthCheckKey'?: string;
    /**
     * 
     * @type {I18nCfg}
     * @memberof AppCfg
     */
    'i18n'?: I18nCfg;
}
/**
 * 
 * @export
 * @interface AppSecretAuthCfg
 */
export interface AppSecretAuthCfg {
    /**
     * 
     * @type {CodeCfg}
     * @memberof AppSecretAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AppSecretAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof AppSecretAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppSecretAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof AppSecretAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AuthCfg
 */
export interface AuthCfg {
    /**
     * 
     * @type {CodeCfg}
     * @memberof AuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof AuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AuthCodeHandlerCfg
 */
export interface AuthCodeHandlerCfg {
    /**
     * 
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'clientSecret'?: string;
}
/**
 * 
 * @export
 * @interface AuthData
 */
export interface AuthData {
    /**
     * 
     * @type {object}
     * @memberof AuthData
     */
    'public': object;
}
/**
 * 
 * @export
 * @interface AuthExecRes
 */
export interface AuthExecRes {
    /**
     * 
     * @type {BaseAuthRes}
     * @memberof AuthExecRes
     */
    'authRes'?: BaseAuthRes;
    /**
     * 
     * @type {User}
     * @memberof AuthExecRes
     */
    'user'?: User;
    /**
     * 
     * @type {Code}
     * @memberof AuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {string}
     * @memberof AuthExecRes
     */
    'status': AuthExecResStatusEnum;
    /**
     * 
     * @type {Err}
     * @memberof AuthExecRes
     */
    'err'?: Err;
    /**
     * 
     * @type {object}
     * @memberof AuthExecRes
     */
    'resData'?: object;
}

export const AuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type AuthExecResStatusEnum = typeof AuthExecResStatusEnum[keyof typeof AuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface AuthIsNotConfirmed
 */
export interface AuthIsNotConfirmed {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthIsNotEnabled
 */
export interface AuthIsNotEnabled {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequiresAnother
 */
export interface AuthRequiresAnother {
    /**
     * 
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthRes
 */
export interface AuthRes {
    /**
     * 
     * @type {object}
     * @memberof AuthRes
     */
    'resData'?: object;
    /**
     * 
     * @type {BaseAuthData}
     * @memberof AuthRes
     */
    'authData'?: BaseAuthData;
}
/**
 * 
 * @export
 * @interface AuthUserCfg
 */
export interface AuthUserCfg {
    /**
     * 
     * @type {AuthData}
     * @memberof AuthUserCfg
     */
    'data'?: AuthData;
    /**
     * 
     * @type {Array<UnconfirmedAuthData>}
     * @memberof AuthUserCfg
     */
    'sentCodes'?: Array<UnconfirmedAuthData>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserCfg
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateReq
 */
export interface AuthenticateReq {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticateReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AuthenticateReq
     */
    'authReqs'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof AuthenticateReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateRes
 */
export interface AuthenticateRes {
    /**
     * 
     * @type {Tokens}
     * @memberof AuthenticateRes
     */
    'tokens'?: Tokens;
    /**
     * 
     * @type {Session}
     * @memberof AuthenticateRes
     */
    'session'?: Session;
    /**
     * 
     * @type {User}
     * @memberof AuthenticateRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof AuthenticateRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface AuthoriseReq
 */
export interface AuthoriseReq {
    /**
     * 
     * @type {RateLimiterReq}
     * @memberof AuthoriseReq
     */
    'rateLimiter'?: RateLimiterReq;
}
/**
 * 
 * @export
 * @interface AuthoriseRes
 */
export interface AuthoriseRes {
    /**
     * 
     * @type {Session}
     * @memberof AuthoriseRes
     */
    'session'?: Session;
}
/**
 * 
 * @export
 * @interface BaseAuthData
 */
export interface BaseAuthData {
    /**
     * 
     * @type {string}
     * @memberof BaseAuthData
     */
    'login'?: string;
}
/**
 * 
 * @export
 * @interface BaseAuthRes
 */
export interface BaseAuthRes {
    /**
     * 
     * @type {BaseAuthData}
     * @memberof BaseAuthRes
     */
    'authData'?: BaseAuthData;
}
/**
 * 
 * @export
 * @interface BuiltInAuthCfg
 */
export interface BuiltInAuthCfg {
    /**
     * 
     * @type {CodeCfg}
     * @memberof BuiltInAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof BuiltInAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof BuiltInAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BuiltInAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof BuiltInAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Cache = {
    Jwt: 'JWT',
    Encoded: 'ENCODED'
} as const;

export type Cache = typeof Cache[keyof typeof Cache];


/**
 * 
 * @export
 * @interface ClientErr
 */
export interface ClientErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Code
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * 
 * @export
 * @interface CodeCfg
 */
export interface CodeCfg {
    /**
     * 
     * @type {number}
     * @memberof CodeCfg
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof CodeCfg
     */
    'ttl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeCfg
     */
    'alphabet'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CodeCfg
     */
    'easyToRemember'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CodeCfg
     */
    'maxAttempts'?: number;
}
/**
 * 
 * @export
 * @interface CodeIsExpired
 */
export interface CodeIsExpired {
    /**
     * 
     * @type {string}
     * @memberof CodeIsExpired
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CodeIsExpired
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof CodeIsExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeIsIncorrect
 */
export interface CodeIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeTooManyAttempts
 */
export interface CodeTooManyAttempts {
    /**
     * 
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeVerifier
 */
export interface CodeVerifier {
    /**
     * 
     * @type {string}
     * @memberof CodeVerifier
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof CodeVerifier
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfirmSessionAuthsReq
 */
export interface ConfirmSessionAuthsReq {
    /**
     * 
     * @type {string}
     * @memberof ConfirmSessionAuthsReq
     */
    'sessionId'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmSessionAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface ConfirmUserAuthsReq
 */
export interface ConfirmUserAuthsReq {
    /**
     * 
     * @type {string}
     * @memberof ConfirmUserAuthsReq
     */
    'userId'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmUserAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface DbHealthRes
 */
export interface DbHealthRes {
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'user': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'session': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'rateLimiter': HealthStatusRes;
}
/**
 * 
 * @export
 * @interface DbsCfg
 */
export interface DbsCfg {
    /**
     * 
     * @type {object}
     * @memberof DbsCfg
     */
    'user': object;
    /**
     * 
     * @type {object}
     * @memberof DbsCfg
     */
    'session': object;
    /**
     * 
     * @type {object}
     * @memberof DbsCfg
     */
    'rateLimiter': object;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'userAgent': string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'mobile'?: boolean;
}
/**
 * 
 * @export
 * @interface DryRunAuthRes
 */
export interface DryRunAuthRes {
    /**
     * 
     * @type {object}
     * @memberof DryRunAuthRes
     */
    'resData'?: object;
    /**
     * 
     * @type {BaseAuthData}
     * @memberof DryRunAuthRes
     */
    'authData'?: BaseAuthData;
}
/**
 * 
 * @export
 * @interface EditUserReq
 */
export interface EditUserReq {
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'systemAccess'?: boolean;
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof EditUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EditUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof EditUserReq
     */
    'authReqs'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailAuthCfg
 */
export interface EmailAuthCfg {
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'server'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'confirmationUrl'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailAuthCfg
     */
    'templates'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailAuthCfg
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof EmailAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof EmailAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof EmailAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof EmailAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface EmailIsIncorrect
 */
export interface EmailIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EntryAccessTokenCfg
 */
export interface EntryAccessTokenCfg {
    /**
     * 
     * @type {string}
     * @memberof EntryAccessTokenCfg
     */
    'ttl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntryAccessTokenCfg
     */
    'cache'?: boolean;
}
/**
 * 
 * @export
 * @interface EntryCfg
 */
export interface EntryCfg {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsRequired'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsOptional'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EntryCfg
     */
    'requiresEntry'?: Array<string>;
    /**
     * 
     * @type {EntryAccessTokenCfg}
     * @memberof EntryCfg
     */
    'accessToken'?: EntryAccessTokenCfg;
    /**
     * 
     * @type {string}
     * @memberof EntryCfg
     */
    'ttl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EntryCfg
     */
    'editAccount'?: boolean;
}
/**
 * 
 * @export
 * @interface Err
 */
export interface Err {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ErrAuthExecRes
 */
export interface ErrAuthExecRes {
    /**
     * 
     * @type {Err}
     * @memberof ErrAuthExecRes
     */
    'err'?: Err;
    /**
     * 
     * @type {BaseAuthRes}
     * @memberof ErrAuthExecRes
     */
    'authRes'?: BaseAuthRes;
    /**
     * 
     * @type {User}
     * @memberof ErrAuthExecRes
     */
    'user'?: User;
    /**
     * 
     * @type {Code}
     * @memberof ErrAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {string}
     * @memberof ErrAuthExecRes
     */
    'status': ErrAuthExecResStatusEnum;
}

export const ErrAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type ErrAuthExecResStatusEnum = typeof ErrAuthExecResStatusEnum[keyof typeof ErrAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface FindSessionsRes
 */
export interface FindSessionsRes {
    /**
     * 
     * @type {Array<Session>}
     * @memberof FindSessionsRes
     */
    'sessions': Array<Session>;
    /**
     * 
     * @type {boolean}
     * @memberof FindSessionsRes
     */
    'tooManySessions'?: boolean;
}
/**
 * 
 * @export
 * @interface HealthRes
 */
export interface HealthRes {
    /**
     * 
     * @type {DbHealthRes}
     * @memberof HealthRes
     */
    'db': DbHealthRes;
    /**
     * 
     * @type {{ [key: string]: HealthStatusRes; }}
     * @memberof HealthRes
     */
    'auth': { [key: string]: HealthStatusRes; };
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthRes
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HealthStatus = {
    Healthy: 'HEALTHY',
    Unavailable: 'UNAVAILABLE',
    Err: 'ERR'
} as const;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


/**
 * 
 * @export
 * @interface HealthStatusRes
 */
export interface HealthStatusRes {
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthStatusRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthStatusRes
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface HttpCfg
 */
export interface HttpCfg {
    /**
     * 
     * @type {boolean}
     * @memberof HttpCfg
     */
    'proxy'?: boolean;
}
/**
 * 
 * @export
 * @interface I18nCfg
 */
export interface I18nCfg {
    /**
     * 
     * @type {string}
     * @memberof I18nCfg
     */
    'dir'?: string;
    /**
     * 
     * @type {string}
     * @memberof I18nCfg
     */
    'default'?: string;
}
/**
 * 
 * @export
 * @interface InMemoryCfg
 */
export interface InMemoryCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InMemoryCfg
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InMemoryCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof InMemoryCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof InMemoryCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface InTokenCfg
 */
export interface InTokenCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InTokenCfg
     */
    'inToken'?: boolean;
}
/**
 * 
 * @export
 * @interface IntegrationErr
 */
export interface IntegrationErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof IntegrationErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface IpAuthCfg
 */
export interface IpAuthCfg {
    /**
     * 
     * @type {number}
     * @memberof IpAuthCfg
     */
    'ipBytesToIgnore'?: number;
    /**
     * 
     * @type {number}
     * @memberof IpAuthCfg
     */
    'historySize'?: number;
    /**
     * 
     * @type {CodeCfg}
     * @memberof IpAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof IpAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof IpAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IpAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof IpAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface IpNew
 */
export interface IpNew {
    /**
     * 
     * @type {string}
     * @memberof IpNew
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof IpNew
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof IpNew
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface JdbcCfg
 */
export interface JdbcCfg {
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof JdbcCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'unconfirmedLogin'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Login
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginId
 */
export interface LoginId {
    /**
     * 
     * @type {string}
     * @memberof LoginId
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof LoginId
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface MariadbCfg
 */
export interface MariadbCfg {
    /**
     * 
     * @type {string}
     * @memberof MariadbCfg
     */
    'mariadb'?: string;
    /**
     * 
     * @type {string}
     * @memberof MariadbCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof MariadbCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof MariadbCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface MongoCfg
 */
export interface MongoCfg {
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'mongodb': string;
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'database': string;
}
/**
 * 
 * @export
 * @interface MysqlCfg
 */
export interface MysqlCfg {
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof MysqlCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface NewSessionReq
 */
export interface NewSessionReq {
    /**
     * 
     * @type {string}
     * @memberof NewSessionReq
     */
    'entry': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NewSessionReq
     */
    'authReqs'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signIn'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signUp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface NextFactor
 */
export interface NextFactor {
    /**
     * 
     * @type {string}
     * @memberof NextFactor
     */
    'factor': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof NextFactor
     */
    'supportedAuths': Set<string>;
}
/**
 * 
 * @export
 * @interface NoAuthAvailableForFactor
 */
export interface NoAuthAvailableForFactor {
    /**
     * 
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface OAuthCfg
 */
export interface OAuthCfg {
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'tokenUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'clientId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'userInfoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'sendTokenInQuery'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthCfg
     */
    'sendTokenInHeader'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'extractLogin'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OAuthCfg
     */
    'extractPublicData'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof OAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof OAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface OkAuthExecRes
 */
export interface OkAuthExecRes {
    /**
     * 
     * @type {object}
     * @memberof OkAuthExecRes
     */
    'resData'?: object;
    /**
     * 
     * @type {BaseAuthRes}
     * @memberof OkAuthExecRes
     */
    'authRes'?: BaseAuthRes;
    /**
     * 
     * @type {User}
     * @memberof OkAuthExecRes
     */
    'user'?: User;
    /**
     * 
     * @type {Code}
     * @memberof OkAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {string}
     * @memberof OkAuthExecRes
     */
    'status': OkAuthExecResStatusEnum;
}

export const OkAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type OkAuthExecResStatusEnum = typeof OkAuthExecResStatusEnum[keyof typeof OkAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface PasswordAuthCfg
 */
export interface PasswordAuthCfg {
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'maxLength'?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'minLength'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidLoginAsPassword'?: boolean;
    /**
     * 
     * @type {PasswordHistoryCfg}
     * @memberof PasswordAuthCfg
     */
    'forbidReusingPassword'?: PasswordHistoryCfg;
    /**
     * 
     * @type {{ [key: string]: PasswordStrengthRequirements; }}
     * @memberof PasswordAuthCfg
     */
    'strength'?: { [key: string]: PasswordStrengthRequirements; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof PasswordAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof PasswordAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface PasswordHistoryCfg
 */
export interface PasswordHistoryCfg {
    /**
     * 
     * @type {number}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistorySize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistoryTtl'?: string;
}
/**
 * 
 * @export
 * @interface PasswordIsIncorrect
 */
export interface PasswordIsIncorrect {
    /**
     * 
     * @type {number}
     * @memberof PasswordIsIncorrect
     */
    'changedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PasswordIsInvalid
 */
export interface PasswordIsInvalid {
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooLong': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingNumber': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingSymbol': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'requireUpperCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'requireLowerCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'commonPassword': boolean;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsInvalid
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'matchesLogin': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'passwordsMismatch': boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'strength'?: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PasswordStrengthRequirements
 */
export interface PasswordStrengthRequirements {
    /**
     * 
     * @type {number}
     * @memberof PasswordStrengthRequirements
     */
    'minLength'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidLoginAsPassword'?: boolean;
}
/**
 * 
 * @export
 * @interface PluginClientErr
 */
export interface PluginClientErr {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof PluginClientErr
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof PluginClientErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PluginClientErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof PluginClientErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PluginErr
 */
export interface PluginErr {
    /**
     * 
     * @type {string}
     * @memberof PluginErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof PluginErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof PluginErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PostgresCfg
 */
export interface PostgresCfg {
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostgresCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersIncorrect
 */
export interface QuestionsAnswersIncorrect {
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'incorrectAnswers': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersIncorrect
     */
    'requiresMoreAnswers': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'questionsNotFound': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersInvalid
 */
export interface QuestionsAnswersInvalid {
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof QuestionsAnswersInvalid
     */
    'invalidAnswers': { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersInvalid
     */
    'tooManyAnswers': boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface QuestionsAuthCfg
 */
export interface QuestionsAuthCfg {
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'lowercase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSymbols'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSpaces'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'minLength'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxLength'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'answersRequired'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxAnswers'?: number;
    /**
     * 
     * @type {CodeCfg}
     * @memberof QuestionsAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof QuestionsAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionsAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface RateLimiterCfg
 */
export interface RateLimiterCfg {
    /**
     * 
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'userId'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'ip'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RateLimiterCfg
     */
    'quota'?: number;
    /**
     * 
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'period'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'alignLoad'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'parent'?: string;
}
/**
 * 
 * @export
 * @interface RateLimiterReq
 */
export interface RateLimiterReq {
    /**
     * 
     * @type {string}
     * @memberof RateLimiterReq
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof RateLimiterReq
     */
    'quotaToBurn': number;
}
/**
 * 
 * @export
 * @interface RedisCfg
 */
export interface RedisCfg {
    /**
     * 
     * @type {Array<string>}
     * @memberof RedisCfg
     */
    'redis': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'database'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface RefreshTokenCfg
 */
export interface RefreshTokenCfg {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'ttl'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'maxTtl'?: string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'unauthenticatedTtl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RefreshTokenCfg
     */
    'allowReuse'?: boolean;
}
/**
 * 
 * @export
 * @interface RefreshTokenReq
 */
export interface RefreshTokenReq {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenReq
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRes
 */
export interface RefreshTokenRes {
    /**
     * 
     * @type {Tokens}
     * @memberof RefreshTokenRes
     */
    'tokens': Tokens;
    /**
     * 
     * @type {Session}
     * @memberof RefreshTokenRes
     */
    'session': Session;
}
/**
 * 
 * @export
 * @interface RemoteAuthCfg
 */
export interface RemoteAuthCfg {
    /**
     * 
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof RemoteAuthCfg
     */
    'code'?: CodeCfg;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof RemoteAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * 
     * @type {number}
     * @memberof RemoteAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface RemoteDbCfg
 */
export interface RemoteDbCfg {
    /**
     * 
     * @type {string}
     * @memberof RemoteDbCfg
     */
    'remote': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'query': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'headers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SaveUserReq
 */
export interface SaveUserReq {
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof SaveUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SaveUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SaveUserReq
     */
    'authReqs'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof SaveUserReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveUserRes
 */
export interface SaveUserRes {
    /**
     * 
     * @type {User}
     * @memberof SaveUserRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof SaveUserRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface ServerErr
 */
export interface ServerErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ServerErr
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ServerErr
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof ServerErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'entry': string;
    /**
     * 
     * @type {Array<LoginId>}
     * @memberof Session
     */
    'identifiedBy': Array<LoginId>;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Session
     */
    'authenticatedBy': { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: UnconfirmedAuth; }}
     * @memberof Session
     */
    'unconfirmedAuths': { [key: string]: UnconfirmedAuth; };
    /**
     * 
     * @type {Array<NextFactor>}
     * @memberof Session
     */
    'nextFactors': Array<NextFactor>;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'signedInAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'expiresAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'refreshedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'newUser': boolean;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device': Device;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'systemAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'expired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SessionExpired
 */
export interface SessionExpired {
    /**
     * 
     * @type {string}
     * @memberof SessionExpired
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SessionExpired
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof SessionExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SignatureIsIncorrect
 */
export interface SignatureIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SkippedAuthExecRes
 */
export interface SkippedAuthExecRes {
    /**
     * 
     * @type {BaseAuthRes}
     * @memberof SkippedAuthExecRes
     */
    'authRes'?: BaseAuthRes;
    /**
     * 
     * @type {User}
     * @memberof SkippedAuthExecRes
     */
    'user'?: User;
    /**
     * 
     * @type {Code}
     * @memberof SkippedAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {string}
     * @memberof SkippedAuthExecRes
     */
    'status': SkippedAuthExecResStatusEnum;
}

export const SkippedAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type SkippedAuthExecResStatusEnum = typeof SkippedAuthExecResStatusEnum[keyof typeof SkippedAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface SqliteCfg
 */
export interface SqliteCfg {
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'sqlite'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqliteCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface TokenCfg
 */
export interface TokenCfg {
    /**
     * 
     * @type {AccessTokenCfg}
     * @memberof TokenCfg
     */
    'access'?: AccessTokenCfg;
    /**
     * 
     * @type {RefreshTokenCfg}
     * @memberof TokenCfg
     */
    'refresh'?: RefreshTokenCfg;
    /**
     * 
     * @type {boolean}
     * @memberof TokenCfg
     */
    'sameUserAgent'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenExpired
 */
export interface TokenExpired {
    /**
     * 
     * @type {number}
     * @memberof TokenExpired
     */
    'expiredAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenExpired
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TokenExpired
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof TokenExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface TokenHandlerCfg
 */
export interface TokenHandlerCfg {
    /**
     * 
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'userInfoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInQuery'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInHeader'?: boolean;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * 
     * @type {string}
     * @memberof Tokens
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof Tokens
     */
    'refresh': string;
    /**
     * 
     * @type {number}
     * @memberof Tokens
     */
    'accessTokenExpiresAt'?: number;
}
/**
 * 
 * @export
 * @interface TooManyReqs
 */
export interface TooManyReqs {
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof TooManyReqs
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TooManyReqs
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof TooManyReqs
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface Unauthenticated
 */
export interface Unauthenticated {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface UnconfirmedAuth
 */
export interface UnconfirmedAuth {
    /**
     * 
     * @type {Array<CodeVerifier>}
     * @memberof UnconfirmedAuth
     */
    'sentCodes'?: Array<CodeVerifier>;
}
/**
 * 
 * @export
 * @interface UnconfirmedAuthData
 */
export interface UnconfirmedAuthData {
    /**
     * 
     * @type {AuthData}
     * @memberof UnconfirmedAuthData
     */
    'data': AuthData;
    /**
     * 
     * @type {CodeVerifier}
     * @memberof UnconfirmedAuthData
     */
    'code': CodeVerifier;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Generated user uuid 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {Array<Login>}
     * @memberof User
     */
    'logins': Array<Login>;
    /**
     * 
     * @type {{ [key: string]: AuthUserCfg; }}
     * @memberof User
     */
    'auths': { [key: string]: AuthUserCfg; };
    /**
     * 
     * @type {Set<string>}
     * @memberof User
     */
    'factors': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'signedUpAt': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'systemAccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'new'?: boolean;
}
/**
 * 
 * @export
 * @interface UserLoginAlreadyTaken
 */
export interface UserLoginAlreadyTaken {
    /**
     * 
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface UserNotFound
 */
export interface UserNotFound {
    /**
     * 
     * @type {string}
     * @memberof UserNotFound
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof UserNotFound
     */
    'devMsg': string;
    /**
     * 
     * @type {string}
     * @memberof UserNotFound
     */
    'msg'?: string;
}

/**
 * AuthorisationApi - axios parameter creator
 * @export
 */
export const AuthorisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthoriseReq} authoriseReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (authoriseReq: AuthoriseReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authoriseReq' is not null or undefined
            assertParamExists('authorize', 'authoriseReq', authoriseReq)
            const localVarPath = `/api/authorise`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authoriseReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit: async (rateLimiterReq: RateLimiterReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateLimiterReq' is not null or undefined
            assertParamExists('limit', 'rateLimiterReq', rateLimiterReq)
            const localVarPath = `/api/rate-limiter/limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateLimiterReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorisationApi - functional programming interface
 * @export
 */
export const AuthorisationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorisationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthoriseReq} authoriseReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(authoriseReq: AuthoriseReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthoriseRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(authoriseReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthoriseRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limit(rateLimiterReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorisationApi - factory interface
 * @export
 */
export const AuthorisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorisationApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthoriseReq} authoriseReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(authoriseReq: AuthoriseReq, options?: any): AxiosPromise<AuthoriseRes> {
            return localVarFp.authorize(authoriseReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit(rateLimiterReq: RateLimiterReq, options?: any): AxiosPromise<AuthoriseRes> {
            return localVarFp.limit(rateLimiterReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorisationApi - object-oriented interface
 * @export
 * @class AuthorisationApi
 * @extends {BaseAPI}
 */
export class AuthorisationApi extends BaseAPI {
    /**
     * 
     * @param {AuthoriseReq} authoriseReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public authorize(authoriseReq: AuthoriseReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).authorize(authoriseReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RateLimiterReq} rateLimiterReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).limit(rateLimiterReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/cfg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfg(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AppCfg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfg(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg(options?: any): AxiosPromise<AppCfg> {
            return localVarFp.cfg(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(key?: string, options?: any): AxiosPromise<HealthRes> {
            return localVarFp.health(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public cfg(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).cfg(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public health(key?: string, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).health(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateReq: AuthenticateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateReq' is not null or undefined
            assertParamExists('authenticate', 'authenticateReq', authenticateReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths: async (confirmSessionAuthsReq: ConfirmSessionAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmSessionAuthsReq' is not null or undefined
            assertParamExists('confirmSessionAuths', 'confirmSessionAuthsReq', confirmSessionAuthsReq)
            const localVarPath = `/api/session/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSessionAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (entry?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)

            if (entry !== undefined) {
                localVarQueryParameter['entry'] = entry;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession: async (newSessionReq: NewSessionReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newSessionReq' is not null or undefined
            assertParamExists('newSession', 'newSessionReq', newSessionReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSessionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remSession: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('remSession', 'sessionId', sessionId)
            const localVarPath = `/api/session/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSessionAuths(confirmSessionAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(entry?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSessionsRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(entry, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newSession(newSessionReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async remSession(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.remSession(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateReq: AuthenticateReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.authenticate(authenticateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(entry?: string, userId?: string, options?: any): AxiosPromise<FindSessionsRes> {
            return localVarFp.getAll(entry, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(newSessionReq: NewSessionReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.newSession(newSessionReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        remSession(sessionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.remSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut(options?: any): AxiosPromise<object> {
            return localVarFp.signOut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticateReq} authenticateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).authenticate(authenticateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [entry] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAll(entry?: string, userId?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getAll(entry, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSession(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NewSessionReq} newSessionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).newSession(newSessionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public remSession(sessionId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).remSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public signOut(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).signOut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignatureApi - axios parameter creator
 * @export
 */
export const SignatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/signature/public-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sign', 'body', body)
            const localVarPath = `/api/signature/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (signature: string, body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('verify', 'signature', signature)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('verify', 'body', body)
            const localVarPath = `/api/signature/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignatureApi - functional programming interface
 * @export
 */
export const SignatureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignatureApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(signature, body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignatureApi - factory interface
 * @export
 */
export const SignatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignatureApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any): AxiosPromise<string> {
            return localVarFp.getPublicKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(body: string, secret?: string, options?: any): AxiosPromise<string> {
            return localVarFp.sign(body, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(signature: string, body: string, secret?: string, options?: any): AxiosPromise<void> {
            return localVarFp.verify(signature, body, secret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignatureApi - object-oriented interface
 * @export
 * @class SignatureApi
 * @extends {BaseAPI}
 */
export class SignatureApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public getPublicKey(options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).getPublicKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public sign(body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).sign(body, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} signature 
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).verify(signature, body, secret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenReq: RefreshTokenReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenReq' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenReq', refreshTokenReq)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * 
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenReq: RefreshTokenReq, options?: any): AxiosPromise<RefreshTokenRes> {
            return localVarFp.refreshToken(refreshTokenReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * 
     * @param {RefreshTokenReq} refreshTokenReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig) {
        return TokenApiFp(this.configuration).refreshToken(refreshTokenReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths: async (confirmUserAuthsReq: ConfirmUserAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmUserAuthsReq' is not null or undefined
            assertParamExists('confirmUserAuths', 'confirmUserAuthsReq', confirmUserAuthsReq)
            const localVarPath = `/api/user/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmUserAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (id: string, editUserReq: EditUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUser', 'id', id)
            // verify required parameter 'editUserReq' is not null or undefined
            assertParamExists('editUser', 'editUserReq', editUserReq)
            const localVarPath = `/api/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (saveUserReq: SaveUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveUserReq' is not null or undefined
            assertParamExists('saveUser', 'saveUserReq', saveUserReq)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            await setApiKeyToObject(localVarQueryParameter, "access-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmUserAuths(confirmUserAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(id, editUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(saveUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(id: string, editUserReq: EditUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.editUser(id, editUserReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(saveUserReq: SaveUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.saveUser(saveUserReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {EditUserReq} editUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(id, editUserReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveUserReq} saveUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).saveUser(saveUserReq, options).then((request) => request(this.axios, this.basePath));
    }
}


