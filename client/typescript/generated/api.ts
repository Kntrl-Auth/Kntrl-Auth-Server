/* tslint:disable */
/* eslint-disable */
/**
 * Kntrl API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessDenied
 */
export interface AccessDenied {
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AccessDenied
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AccessDenied
     */
    'msg'?: string;
}
/**
 * Short-living token used for authentication.
 * @export
 * @interface AccessTokenCfg
 */
export interface AccessTokenCfg {
    /**
     * Send token in `access_token` cookie
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cookie'?: boolean;
    /**
     * If not null - access token contains signed session data, so it\'s not required to request session database for access check.
     * @type {string}
     * @memberof AccessTokenCfg
     */
    'cache'?: AccessTokenCfgCacheEnum;
    /**
     * By default, unauthenticated sessions can\'t be cached.
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cacheUnauthenticated'?: boolean;
    /**
     * Lifetime for access token. 1d, 30m, etc. 
     * @type {string}
     * @memberof AccessTokenCfg
     */
    'ttl'?: string;
}

export const AccessTokenCfgCacheEnum = {
    Jwt: 'JWT',
    Binary: 'BINARY'
} as const;

export type AccessTokenCfgCacheEnum = typeof AccessTokenCfgCacheEnum[keyof typeof AccessTokenCfgCacheEnum];

/**
 * 
 * @export
 * @interface AnswerErr
 */
export interface AnswerErr {
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooLong': boolean;
}
/**
 * 
 * @export
 * @interface AnswersTransformationCfg
 */
export interface AnswersTransformationCfg {
    /**
     * Transform user answer to lowercase letters. This allows user still pass a check when he wrote name or city with different cases. `false` means strict match, so \"John\" != \"john\"
     * @type {boolean}
     * @memberof AnswersTransformationCfg
     */
    'lowercase'?: boolean;
    /**
     * Remove all non-letters from user answer.
     * @type {boolean}
     * @memberof AnswersTransformationCfg
     */
    'removeSymbols'?: boolean;
    /**
     * Remove all spaces from user answer.
     * @type {boolean}
     * @memberof AnswersTransformationCfg
     */
    'removeSpaces'?: boolean;
}
/**
 * 
 * @export
 * @interface AnyErr
 */
export interface AnyErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AnyErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AnyErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AnyErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AppSecretAuthCfg
 */
export interface AppSecretAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof AppSecretAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof AppSecretAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof AppSecretAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof AppSecretAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AppSecretReqData
 */
export interface AppSecretReqData {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AppSecretReqData
     */
    'secret': string;
}
/**
 * Authentication implementation config
 * @export
 * @interface AuthAppCfg
 */
export interface AuthAppCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof AuthAppCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof AuthAppCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof AuthAppCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof AuthAppCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AuthData
 */
export interface AuthData {
    /**
     * 
     * @type {AuthDataPublic}
     * @memberof AuthData
     */
    'public': AuthDataPublic;
    /**
     * If authenticator supports identification, it provides login here. This can be email, phone number, facebook account id, etc.
     * @type {string}
     * @memberof AuthData
     */
    'login'?: string;
}
/**
 * 
 * @export
 * @interface AuthDataPublic
 */
export interface AuthDataPublic {
    [key: string]: any;

    /**
     * User email.
     * @type {string}
     * @memberof AuthDataPublic
     */
    'email'?: string;
    /**
     * Time when password was updated last time.
     * @type {number}
     * @memberof AuthDataPublic
     */
    'updatedAt'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AuthDataPublic
     */
    'answersSavedAt'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface AuthExecRes
 */
export interface AuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof AuthExecRes
     */
    'status': AuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof AuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {Err}
     * @memberof AuthExecRes
     */
    'err'?: Err;
    /**
     * 
     * @type {AuthExecResResData}
     * @memberof AuthExecRes
     */
    'resData'?: AuthExecResResData;
}

export const AuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type AuthExecResStatusEnum = typeof AuthExecResStatusEnum[keyof typeof AuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface AuthExecResResData
 */
export interface AuthExecResResData {
    [key: string]: any;

    /**
     * Shows user email, that was used to send a code. Email will be partially hidden.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'emailSentTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthExecResResData
     */
    'ipEncoded'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthExecResResData
     */
    'extractedLogin'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AuthExecResResData
     */
    'extractedPublicData'?: { [key: string]: any; };
    /**
     * If password was generated by app this field contains generated password.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'password'?: string;
    /**
     * Calculated strength of password. Null means that all checks failed.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'strength'?: string;
    /**
     * Shows is answer was correct. 
     * @type {{ [key: string]: boolean; }}
     * @memberof AuthExecResResData
     */
    'correct'?: { [key: string]: boolean; };
    /**
     * Date of last update 
     * @type {{ [key: string]: number; }}
     * @memberof AuthExecResResData
     */
    'answersSavedAt'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface AuthIsNotConfirmed
 */
export interface AuthIsNotConfirmed {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthIsNotEnabled
 */
export interface AuthIsNotEnabled {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequiresAnother
 */
export interface AuthRequiresAnother {
    /**
     * 
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthUserCfg
 */
export interface AuthUserCfg {
    /**
     * 
     * @type {AuthData}
     * @memberof AuthUserCfg
     */
    'data'?: AuthData;
    /**
     * List of auths that wait for confirmation. 
     * @type {Array<UnconfirmedAuthData>}
     * @memberof AuthUserCfg
     */
    'sentCodes'?: Array<UnconfirmedAuthData>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserCfg
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateReq
 */
export interface AuthenticateReq {
    /**
     * Forces specific auth to be used for factor. Takes place only when multiple auths is provided within request and auth can be assigned to several factors. If used in sign-up mode, it just enables those factors. 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticateReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * Request for authenticators 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof AuthenticateReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * Execute only validation ща authenticator requests.
     * @type {boolean}
     * @memberof AuthenticateReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateReqAuthReqsValue
 */
export interface AuthenticateReqAuthReqsValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'secret'?: string;
    /**
     * New email to set.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'email'?: string;
    /**
     * Template to use.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'template'?: string;
    /**
     * Template params
     * @type {{ [key: string]: object; }}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'templateParams'?: { [key: string]: object; };
    /**
     * If you have access-token - put it here.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'accessToken'?: string;
    /**
     * If you have authorisation-code - app will exchange it for access-token.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'authorizationCode'?: string;
    /**
     * Redirect uri used when requested user login.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'redirectUri'?: string;
    /**
     * New password to set. If null app generates password automatically.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'password'?: string;
    /**
     * Password confirmation. If null app doesn\'t perform this check.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'confirmPassword'?: string;
    /**
     * Answers to save. `null` as value removes answer 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'answers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AuthenticateRes
 */
export interface AuthenticateRes {
    /**
     * 
     * @type {Tokens}
     * @memberof AuthenticateRes
     */
    'tokens'?: Tokens;
    /**
     * 
     * @type {Session}
     * @memberof AuthenticateRes
     */
    'session'?: Session;
    /**
     * 
     * @type {User}
     * @memberof AuthenticateRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof AuthenticateRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface AuthorizeReq
 */
export interface AuthorizeReq {
    /**
     * Require OAuth scopes
     * @type {Array<string>}
     * @memberof AuthorizeReq
     */
    'requireScopes'?: Array<string>;
    /**
     * 
     * @type {RateLimiterReq}
     * @memberof AuthorizeReq
     */
    'rateLimiter'?: RateLimiterReq;
}
/**
 * 
 * @export
 * @interface AuthorizeRes
 */
export interface AuthorizeRes {
    /**
     * 
     * @type {Session}
     * @memberof AuthorizeRes
     */
    'session'?: Session;
}
/**
 * Authentication implementation config
 * @export
 * @interface BuiltInAuthCfg
 */
export interface BuiltInAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof BuiltInAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof BuiltInAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof BuiltInAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof BuiltInAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Cache = {
    Jwt: 'JWT',
    Binary: 'BINARY'
} as const;

export type Cache = typeof Cache[keyof typeof Cache];


/**
 * 
 * @export
 * @interface ClientErr
 */
export interface ClientErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof ClientErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof ClientErr
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'changedDaysAgo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooLong'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooShort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingLowerCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'commonPassword'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof ClientErr
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'passwordsMismatch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'wasUsedDaysAgo'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientErr
     */
    'incorrectAnswers'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'requiresMoreAnswers'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientErr
     */
    'questionsNotFound'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof ClientErr
     */
    'invalidAnswers'?: { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooManyAnswers'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'expiredAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof ClientErr
     */
    'loginId'?: LoginId;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClientErrCode = {
    PluginClientErr: 'PLUGIN_CLIENT_ERR',
    PasswordIsIncorrect: 'PASSWORD_IS_INCORRECT',
    PasswordIsInvalid: 'PASSWORD_IS_INVALID',
    EmailIsIncorrect: 'EMAIL_IS_INCORRECT',
    IpNew: 'IP_NEW',
    QuestionsAnswersIncorrect: 'QUESTIONS_ANSWERS_INCORRECT',
    QuestionsAnswersInvalid: 'QUESTIONS_ANSWERS_INVALID',
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    SignatureIsIncorrect: 'SIGNATURE_IS_INCORRECT',
    UserLoginIsInvalid: 'USER_LOGIN_IS_INVALID',
    UserLoginAlreadyTaken: 'USER_LOGIN_ALREADY_TAKEN',
    TokenExpired: 'TOKEN_EXPIRED',
    TooManyReqs: 'TOO_MANY_REQS',
    AuthIsNotEnabled: 'AUTH_IS_NOT_ENABLED',
    AuthIsNotConfirmed: 'AUTH_IS_NOT_CONFIRMED',
    AuthRequiresAnother: 'AUTH_REQUIRES_ANOTHER',
    CodeIsExpired: 'CODE_IS_EXPIRED',
    CodeTooManyAttempts: 'CODE_TOO_MANY_ATTEMPTS',
    CodeIsIncorrect: 'CODE_IS_INCORRECT',
    Unauthenticated: 'UNAUTHENTICATED'
} as const;

export type ClientErrCode = typeof ClientErrCode[keyof typeof ClientErrCode];


/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Code
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * If specified - app generates code and requires auth to be confirmed
 * @export
 * @interface CodeCfg
 */
export interface CodeCfg {
    /**
     * Length of code to be generated
     * @type {number}
     * @memberof CodeCfg
     */
    'length'?: number;
    /**
     * Generated code lifetime. e.g. 1m, 60s, 1d, etc.
     * @type {string}
     * @memberof CodeCfg
     */
    'ttl'?: string;
    /**
     * Symbols used to generate a code. By default `a-z + A-Z + 0-9`.
     * @type {string}
     * @memberof CodeCfg
     */
    'alphabet'?: string;
    /**
     * If true, every second letter will be the same, that allows the codes to rhyme.
     * @type {boolean}
     * @memberof CodeCfg
     */
    'easyToRemember'?: boolean;
    /**
     * Max attempts to enter the code.
     * @type {number}
     * @memberof CodeCfg
     */
    'maxAttempts'?: number;
}
/**
 * 
 * @export
 * @interface CodeIsExpired
 */
export interface CodeIsExpired {
    /**
     * 
     * @type {string}
     * @memberof CodeIsExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeIsExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeIsExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeIsIncorrect
 */
export interface CodeIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeTooManyAttempts
 */
export interface CodeTooManyAttempts {
    /**
     * 
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeVerifier
 */
export interface CodeVerifier {
    /**
     * 
     * @type {string}
     * @memberof CodeVerifier
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof CodeVerifier
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfirmSessionAuthsReq
 */
export interface ConfirmSessionAuthsReq {
    /**
     * If null, session id will be extracted from access-token. Useful to confirm auth from another device where no access-token available.
     * @type {string}
     * @memberof ConfirmSessionAuthsReq
     */
    'sessionId'?: string;
    /**
     * The code from authenticate/new-session response. 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmSessionAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface ConfirmUserAuthsReq
 */
export interface ConfirmUserAuthsReq {
    /**
     * If null, user id will be extracted from access-token. Useful to confirm auth from another device where no access-token available.
     * @type {string}
     * @memberof ConfirmUserAuthsReq
     */
    'userId'?: string;
    /**
     * The code from save-user response. 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmUserAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface DbHealthRes
 */
export interface DbHealthRes {
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'user': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'session': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'rateLimiter': HealthStatusRes;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'mobile': boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'userAgent': string;
}
/**
 * 
 * @export
 * @interface EditUserReq
 */
export interface EditUserReq {
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof EditUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EditUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof EditUserReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'dryRun'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'systemAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailAuthCfg
 */
export interface EmailAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof EmailAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof EmailAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof EmailAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Email server address/IP.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'server': string;
    /**
     * Email address of sender.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'sender': string;
    /**
     * SMTP username.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'username'?: string;
    /**
     * SMTP password.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'password'?: string;
    /**
     * If not null, server will create template param `confirmationUrl` that will contain query parameters with confirmation code, session id, etc.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'confirmationUrl'?: string;
    /**
     * List of email templates. Key - is name of a template (can be used lately on frontend), value - is path to the template. App uses handlebars templates to generate emails. See docs here https://handlebarsjs.com  Email templates receives `confirmationUrl`, `action`, `user`, `session`, `codeId`, `code`, `codeExpiresInMinutes`, `lang`, `headers` as template params, e.g. you can print user id as `{{user.id}}`.  Template engine also provides `i18n` helper for localisation. E.g. `{{i18n \'confirmationButton\' default=\'Confirm\'}}` searches key `confirmationButton` in files specified by `i18n.dir` config.  Use `{{err ERR_CODE msg=\'Localised message (if null, will be taken from i18n file)\' devMsg=\'dev message\'}}` to raise an error in a template.  It allows setting subject of email using `title` html tag, e.g. `<title>Email subject</title>`.  
     * @type {{ [key: string]: string; }}
     * @memberof EmailAuthCfg
     */
    'templates'?: { [key: string]: string; };
    /**
     * Additional params for templates that can be passed in request. Key - is a name of additional parameter, value - is a default value for this parameter (when no value present in request) 
     * @type {{ [key: string]: object; }}
     * @memberof EmailAuthCfg
     */
    'templateParams'?: { [key: string]: object; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof EmailAuthCfg
     */
    'code'?: CodeCfg;
}
/**
 * 
 * @export
 * @interface EmailAuthReqData
 */
export interface EmailAuthReqData {
    [key: string]: any;

    /**
     * User email. If email is not null - auth allow identification by email (email auth also must be listed in logins config). Otherwise, uses email of already identified user.
     * @type {string}
     * @memberof EmailAuthReqData
     */
    'email'?: string;
    /**
     * Template to use.
     * @type {string}
     * @memberof EmailAuthReqData
     */
    'template'?: string;
    /**
     * Template params
     * @type {{ [key: string]: object; }}
     * @memberof EmailAuthReqData
     */
    'templateParams'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface EmailAuthResData
 */
export interface EmailAuthResData {
    [key: string]: any;

    /**
     * Shows user email, that was used to send a code. Email will be partially hidden.
     * @type {string}
     * @memberof EmailAuthResData
     */
    'emailSentTo'?: string;
}
/**
 * 
 * @export
 * @interface EmailIsIncorrect
 */
export interface EmailIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EmailPublicData
 */
export interface EmailPublicData {
    [key: string]: any;

    /**
     * User email.
     * @type {string}
     * @memberof EmailPublicData
     */
    'email': string;
    /**
     * Last time when email was changed.
     * @type {number}
     * @memberof EmailPublicData
     */
    'updatedAt': number;
}
/**
 * 
 * @export
 * @interface EmailUpdateReqData
 */
export interface EmailUpdateReqData {
    [key: string]: any;

    /**
     * New email to set.
     * @type {string}
     * @memberof EmailUpdateReqData
     */
    'email': string;
    /**
     * Template to use.
     * @type {string}
     * @memberof EmailUpdateReqData
     */
    'template'?: string;
    /**
     * Template params
     * @type {{ [key: string]: object; }}
     * @memberof EmailUpdateReqData
     */
    'templateParams'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface EntryAccessTokenCfg
 */
export interface EntryAccessTokenCfg {
    /**
     * Override access token ttl
     * @type {string}
     * @memberof EntryAccessTokenCfg
     */
    'ttl'?: string;
    /**
     * Enable or disable client-side caching of access token
     * @type {boolean}
     * @memberof EntryAccessTokenCfg
     */
    'cache'?: boolean;
}
/**
 * Configuration for app entry.
 * @export
 * @interface EntryCfg
 */
export interface EntryCfg {
    /**
     * Specifies factors that always required to be authenticated.  Usually it\'s main auth method (e.g. password) + social login (e.g. facebook) + reserve auth option in case of lost/forgotten main auth credentials (e.g. secret questions or email auth).  These factors are always required even when user hasn\'t enabled them explicitly.  
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsRequired'?: { [key: string]: Array<string>; };
    /**
     * This factors can be skipped if user hasn\'t enabled them. Used for optional 2FA. E.g. If user added mobile phone -> use it for 2FA otherwise skip 2FA. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsOptional'?: { [key: string]: Array<string>; };
    /**
     * Require user to be already signed in by one of the listed entries. Usually it used for action confirmation, e.g. \"payment\" that requires confirmation by sms, requires user to be already signed in (e.g. with entry \"app\".
     * @type {Array<string>}
     * @memberof EntryCfg
     */
    'requiresEntry'?: Array<string>;
    /**
     * 
     * @type {EntryCfgAccessToken}
     * @memberof EntryCfg
     */
    'accessToken'?: EntryCfgAccessToken;
    /**
     * Max lifetime of session. 
     * @type {string}
     * @memberof EntryCfg
     */
    'ttl'?: string;
    /**
     * Is this session allowed to add/remove new auth, enable/disable factors, etc.?
     * @type {boolean}
     * @memberof EntryCfg
     */
    'editAccount'?: boolean;
}
/**
 * Override access token lifetime for sessions of this entry.
 * @export
 * @interface EntryCfgAccessToken
 */
export interface EntryCfgAccessToken {
    /**
     * Override access token ttl
     * @type {string}
     * @memberof EntryCfgAccessToken
     */
    'ttl'?: string;
    /**
     * Enable or disable client-side caching of access token
     * @type {boolean}
     * @memberof EntryCfgAccessToken
     */
    'cache'?: boolean;
}
/**
 * 
 * @export
 * @interface Err
 */
export interface Err {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof Err
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof Err
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'changedDaysAgo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooLong'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooShort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingLowerCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'commonPassword'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof Err
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'passwordsMismatch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'wasUsedDaysAgo'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Err
     */
    'incorrectAnswers'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'requiresMoreAnswers'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Err
     */
    'questionsNotFound'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof Err
     */
    'invalidAnswers'?: { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooManyAnswers'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'expiredAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof Err
     */
    'loginId'?: LoginId;
}
/**
 * 
 * @export
 * @interface ErrAuthExecRes
 */
export interface ErrAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof ErrAuthExecRes
     */
    'status': ErrAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof ErrAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {Err}
     * @memberof ErrAuthExecRes
     */
    'err': Err;
}

export const ErrAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type ErrAuthExecResStatusEnum = typeof ErrAuthExecResStatusEnum[keyof typeof ErrAuthExecResStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ErrCode = {
    PluginErr: 'PLUGIN_ERR',
    PluginClientErr: 'PLUGIN_CLIENT_ERR',
    PasswordIsIncorrect: 'PASSWORD_IS_INCORRECT',
    PasswordIsInvalid: 'PASSWORD_IS_INVALID',
    EmailIsIncorrect: 'EMAIL_IS_INCORRECT',
    IpNew: 'IP_NEW',
    QuestionsAnswersIncorrect: 'QUESTIONS_ANSWERS_INCORRECT',
    QuestionsAnswersInvalid: 'QUESTIONS_ANSWERS_INVALID',
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    SignatureIsIncorrect: 'SIGNATURE_IS_INCORRECT',
    UserLoginIsInvalid: 'USER_LOGIN_IS_INVALID',
    UserLoginAlreadyTaken: 'USER_LOGIN_ALREADY_TAKEN',
    TokenExpired: 'TOKEN_EXPIRED',
    TooManyReqs: 'TOO_MANY_REQS',
    AuthIsNotEnabled: 'AUTH_IS_NOT_ENABLED',
    AuthIsNotConfirmed: 'AUTH_IS_NOT_CONFIRMED',
    NoAuthAvailableForFactor: 'NO_AUTH_AVAILABLE_FOR_FACTOR',
    AuthRequiresAnother: 'AUTH_REQUIRES_ANOTHER',
    CodeIsExpired: 'CODE_IS_EXPIRED',
    CodeTooManyAttempts: 'CODE_TOO_MANY_ATTEMPTS',
    CodeIsIncorrect: 'CODE_IS_INCORRECT',
    Unauthenticated: 'UNAUTHENTICATED',
    ServerErr: 'SERVER_ERR',
    IntegrationErr: 'INTEGRATION_ERR',
    AnyErr: 'ANY_ERR'
} as const;

export type ErrCode = typeof ErrCode[keyof typeof ErrCode];


/**
 * 
 * @export
 * @interface ExchangeAuthCodeCfg
 */
export interface ExchangeAuthCodeCfg {
    /**
     * Url to get access token by authorisation code. 
     * @type {string}
     * @memberof ExchangeAuthCodeCfg
     */
    'tokenUrl': string;
    /**
     * OAuth client id. Client must be registered on OAuth provider (e.g. facebook, google)
     * @type {string}
     * @memberof ExchangeAuthCodeCfg
     */
    'clientId'?: string;
    /**
     * OAuth client secret.
     * @type {string}
     * @memberof ExchangeAuthCodeCfg
     */
    'clientSecret'?: string;
}
/**
 * 
 * @export
 * @interface FindSessionsRes
 */
export interface FindSessionsRes {
    /**
     * 
     * @type {Array<Session>}
     * @memberof FindSessionsRes
     */
    'sessions': Array<Session>;
    /**
     * True if number of sessions in database exceeds some limit
     * @type {boolean}
     * @memberof FindSessionsRes
     */
    'tooManySessions'?: boolean;
}
/**
 * 
 * @export
 * @interface HealthRes
 */
export interface HealthRes {
    /**
     * 
     * @type {DbHealthRes}
     * @memberof HealthRes
     */
    'db': DbHealthRes;
    /**
     * 
     * @type {{ [key: string]: HealthStatusRes; }}
     * @memberof HealthRes
     */
    'auth': { [key: string]: HealthStatusRes; };
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthRes
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HealthStatus = {
    Healthy: 'HEALTHY',
    Unavailable: 'UNAVAILABLE',
    Err: 'ERR'
} as const;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


/**
 * 
 * @export
 * @interface HealthStatusRes
 */
export interface HealthStatusRes {
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthStatusRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthStatusRes
     */
    'msg'?: string;
}
/**
 * Configuration for localization of error messages, emails, etc.
 * @export
 * @interface I18nCfg
 */
export interface I18nCfg {
    /**
     * Directory when messages are stored. To support new language add `<lang>.json5` file. App will create helpful templates after start if dir is not null. 
     * @type {string}
     * @memberof I18nCfg
     */
    'dir'?: string;
    /**
     * Default language to use. 
     * @type {string}
     * @memberof I18nCfg
     */
    'default'?: string;
}
/**
 * 
 * @export
 * @interface InMemoryCfg
 */
export interface InMemoryCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InMemoryCfg
     */
    'inMemory'?: boolean;
}
/**
 * 
 * @export
 * @interface InTokenCfg
 */
export interface InTokenCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InTokenCfg
     */
    'inToken'?: boolean;
}
/**
 * 
 * @export
 * @interface IntegrationErr
 */
export interface IntegrationErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof IntegrationErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof IntegrationErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof IntegrationErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationErrCode = {
    NoAuthAvailableForFactor: 'NO_AUTH_AVAILABLE_FOR_FACTOR',
    IntegrationErr: 'INTEGRATION_ERR'
} as const;

export type IntegrationErrCode = typeof IntegrationErrCode[keyof typeof IntegrationErrCode];


/**
 * 
 * @export
 * @interface IpAuthCfg
 */
export interface IpAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof IpAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof IpAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof IpAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof IpAuthCfg
     */
    'burnQuota'?: number;
    /**
     * This allows to drop last bytes of IP. So it allows to authenticate factor when ip has rough match, e.g. the same country, same city, or same internet provider.
     * @type {number}
     * @memberof IpAuthCfg
     */
    'ipBytesToIgnore'?: number;
    /**
     * History of IP addresses user used to sign-in. Authenticated when user attempts to sign in with one of stored IPs.
     * @type {number}
     * @memberof IpAuthCfg
     */
    'historySize'?: number;
}
/**
 * 
 * @export
 * @interface IpAuthResData
 */
export interface IpAuthResData {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof IpAuthResData
     */
    'ipEncoded': string;
}
/**
 * 
 * @export
 * @interface IpNew
 */
export interface IpNew {
    /**
     * 
     * @type {string}
     * @memberof IpNew
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof IpNew
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof IpNew
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface IpPrivateData
 */
export interface IpPrivateData {
    [key: string]: any;

    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof IpPrivateData
     */
    'encodedIps'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface JdbcCfg
 */
export interface JdbcCfg {
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof JdbcCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Type of login
     * @type {string}
     * @memberof Login
     */
    'type': string;
    /**
     * User unique identifier, email, username, etc.
     * @type {string}
     * @memberof Login
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'unconfirmedLogin'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Login
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginId
 */
export interface LoginId {
    /**
     * Type of login
     * @type {string}
     * @memberof LoginId
     */
    'type': string;
    /**
     * User unique identifier, email, username, etc.
     * @type {string}
     * @memberof LoginId
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface MongoCfg
 */
export interface MongoCfg {
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'mongodb': string;
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'database': string;
}
/**
 * 
 * @export
 * @interface MysqlCfg
 */
export interface MysqlCfg {
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof MysqlCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface NewSessionReq
 */
export interface NewSessionReq {
    /**
     * 
     * @type {string}
     * @memberof NewSessionReq
     */
    'entry': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * Forces specific auth to be used for factor. Takes place only when multiple auths is provided within request and auth can be assigned to several factors. If used in sign-up mode, it just enables those factors. 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * Request for authenticators 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof NewSessionReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * OAuth scopes
     * @type {Array<string>}
     * @memberof NewSessionReq
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signIn'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signUp'?: boolean;
    /**
     * Execute only validation ща authenticator requests.
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface NextFactor
 */
export interface NextFactor {
    /**
     * 
     * @type {string}
     * @memberof NextFactor
     */
    'factor': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof NextFactor
     */
    'supportedAuths': Set<string>;
}
/**
 * 
 * @export
 * @interface NoAuthAvailableForFactor
 */
export interface NoAuthAvailableForFactor {
    /**
     * 
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface OAuthCfg
 */
export interface OAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof OAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof OAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof OAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof OAuthCfg
     */
    'burnQuota'?: number;
    /**
     * 
     * @type {OAuthCfgExchangeAuthCode}
     * @memberof OAuthCfg
     */
    'exchangeAuthCode'?: OAuthCfgExchangeAuthCode;
    /**
     * 
     * @type {OAuthCfgUserInfo}
     * @memberof OAuthCfg
     */
    'userInfo'?: OAuthCfgUserInfo;
    /**
     * Json path for login in the exchangeAuthCode or userInfo endpoint response. e.g. `access_token.user.id` extracts user login from `{ \"access_token\": { \"user\": { \"id\": \"...\" } } }` 
     * @type {string}
     * @memberof OAuthCfg
     */
    'extractLogin': string;
    /**
     * Can fill public data from the exchangeAuthCode or userInfo endpoint response. 
     * @type {{ [key: string]: string; }}
     * @memberof OAuthCfg
     */
    'extractPublicData'?: { [key: string]: string; };
}
/**
 * If specified, app is able to handle authorizationCode from auth request; exchanges it for `access_token` or/and `id_token`
 * @export
 * @interface OAuthCfgExchangeAuthCode
 */
export interface OAuthCfgExchangeAuthCode {
    /**
     * Url to get access token by authorisation code. 
     * @type {string}
     * @memberof OAuthCfgExchangeAuthCode
     */
    'tokenUrl': string;
    /**
     * OAuth client id. Client must be registered on OAuth provider (e.g. facebook, google)
     * @type {string}
     * @memberof OAuthCfgExchangeAuthCode
     */
    'clientId'?: string;
    /**
     * OAuth client secret.
     * @type {string}
     * @memberof OAuthCfgExchangeAuthCode
     */
    'clientSecret'?: string;
}
/**
 * If specified, app will use received access token
 * @export
 * @interface OAuthCfgUserInfo
 */
export interface OAuthCfgUserInfo {
    /**
     * If access token provided in request, app tries to extract user id from user-info endpoint. If null, user info will be extracted from access token 
     * @type {string}
     * @memberof OAuthCfgUserInfo
     */
    'url'?: string;
    /**
     * While executing user-info request, access-token will be sent in query param.
     * @type {string}
     * @memberof OAuthCfgUserInfo
     */
    'sendTokenInQuery'?: string;
    /**
     * While executing user-info request, access-token will be sent in Authorisation header.
     * @type {boolean}
     * @memberof OAuthCfgUserInfo
     */
    'sendTokenInHeader'?: boolean;
}
/**
 * 
 * @export
 * @interface OAuthReqData
 */
export interface OAuthReqData {
    [key: string]: any;

    /**
     * If you have access-token - put it here.
     * @type {string}
     * @memberof OAuthReqData
     */
    'accessToken'?: string;
    /**
     * If you have authorisation-code - app will exchange it for access-token.
     * @type {string}
     * @memberof OAuthReqData
     */
    'authorizationCode'?: string;
    /**
     * Redirect uri used when requested user login.
     * @type {string}
     * @memberof OAuthReqData
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface OAuthResData
 */
export interface OAuthResData {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OAuthResData
     */
    'extractedLogin': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof OAuthResData
     */
    'extractedPublicData': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OkAuthExecRes
 */
export interface OkAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof OkAuthExecRes
     */
    'status': OkAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof OkAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {AuthExecResResData}
     * @memberof OkAuthExecRes
     */
    'resData'?: AuthExecResResData;
}

export const OkAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type OkAuthExecResStatusEnum = typeof OkAuthExecResStatusEnum[keyof typeof OkAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface Password
 */
export interface Password {
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    'hash': string;
    /**
     * 
     * @type {number}
     * @memberof Password
     */
    'createdAt': number;
}
/**
 * Password authentication. To enable this auth set auth name to \"password\" or use \"builtin\": \"password\" param.
 * @export
 * @interface PasswordAuthCfg
 */
export interface PasswordAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof PasswordAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof PasswordAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Max allowed Length of the password.
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'maxLength'?: number;
    /**
     * Minimal length of password
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidLoginAsPassword'?: boolean;
    /**
     * 
     * @type {PasswordHistoryCfg}
     * @memberof PasswordAuthCfg
     */
    'forbidReusingPassword'?: PasswordHistoryCfg;
    /**
     * Allows to calculate password strength based on mentioned criteria. Requirements will be checked one by one until first failed. 
     * @type {{ [key: string]: PasswordStrengthRequirements; }}
     * @memberof PasswordAuthCfg
     */
    'strength'?: { [key: string]: PasswordStrengthRequirements; };
}
/**
 * 
 * @export
 * @interface PasswordAuthReqData
 */
export interface PasswordAuthReqData {
    [key: string]: any;

    /**
     * User password.
     * @type {string}
     * @memberof PasswordAuthReqData
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface PasswordHistory
 */
export interface PasswordHistory {
    [key: string]: any;

    /**
     * 
     * @type {Array<Password>}
     * @memberof PasswordHistory
     */
    'passwords'?: Array<Password>;
    /**
     * 
     * @type {number}
     * @memberof PasswordHistory
     */
    'changedAt'?: number;
}
/**
 * Forbids user to change password to the old one. Useful if you force user to change password regularly.
 * @export
 * @interface PasswordHistoryCfg
 */
export interface PasswordHistoryCfg {
    /**
     * Number of current user passwords to store in database.
     * @type {number}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistorySize'?: number;
    /**
     * Lifetime for the password. Accepts time string e.g. 1y, 3m, 2y 6m, etc.
     * @type {string}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistoryTtl'?: string;
}
/**
 * 
 * @export
 * @interface PasswordIsIncorrect
 */
export interface PasswordIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsIncorrect
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsIncorrect
     */
    'changedDaysAgo'?: number;
}
/**
 * 
 * @export
 * @interface PasswordIsInvalid
 */
export interface PasswordIsInvalid {
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'msg'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooLong': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingNumber': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingSymbol': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingUpperCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingLowerCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'commonPassword': boolean;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsInvalid
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof PasswordIsInvalid
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'passwordsMismatch': boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsInvalid
     */
    'wasUsedDaysAgo'?: number;
}
/**
 * 
 * @export
 * @interface PasswordPublicData
 */
export interface PasswordPublicData {
    [key: string]: any;

    /**
     * Time when password was updated last time.
     * @type {number}
     * @memberof PasswordPublicData
     */
    'updatedAt': number;
}
/**
 * Requirements for password
 * @export
 * @interface PasswordStrengthRequirements
 */
export interface PasswordStrengthRequirements {
    /**
     * Minimal length of password
     * @type {number}
     * @memberof PasswordStrengthRequirements
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidLoginAsPassword'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordUpdateReqData
 */
export interface PasswordUpdateReqData {
    [key: string]: any;

    /**
     * New password to set. If null app generates password automatically.
     * @type {string}
     * @memberof PasswordUpdateReqData
     */
    'password'?: string;
    /**
     * Password confirmation. If null app doesn\'t perform this check.
     * @type {string}
     * @memberof PasswordUpdateReqData
     */
    'confirmPassword'?: string;
}
/**
 * 
 * @export
 * @interface PasswordUpdateResData
 */
export interface PasswordUpdateResData {
    [key: string]: any;

    /**
     * If password was generated by app this field contains generated password.
     * @type {string}
     * @memberof PasswordUpdateResData
     */
    'password': string;
    /**
     * Calculated strength of password. Null means that all checks failed.
     * @type {string}
     * @memberof PasswordUpdateResData
     */
    'strength'?: string;
}
/**
 * 
 * @export
 * @interface PluginClientErr
 */
export interface PluginClientErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof PluginClientErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PluginClientErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PluginClientErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PluginErr
 */
export interface PluginErr {
    /**
     * 
     * @type {string}
     * @memberof PluginErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PluginErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PluginErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PostgresCfg
 */
export interface PostgresCfg {
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostgresCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface PublicCfgAuth
 */
export interface PublicCfgAuth {
    /**
     * 
     * @type {string}
     * @memberof PublicCfgAuth
     */
    'auth': string;
    /**
     * 
     * @type {string}
     * @memberof PublicCfgAuth
     */
    'authType': string;
}
/**
 * 
 * @export
 * @interface PublicCfgRes
 */
export interface PublicCfgRes {
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicCfgRes
     */
    'logins': Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PublicCfgRes
     */
    'loginRequirements': { [key: string]: string; };
    /**
     * 
     * @type {Array<PublicCfgAuth>}
     * @memberof PublicCfgRes
     */
    'auths': Array<PublicCfgAuth>;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersIncorrect
 */
export interface QuestionsAnswersIncorrect {
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'msg'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'incorrectAnswers': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersIncorrect
     */
    'requiresMoreAnswers': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'questionsNotFound': Array<string>;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersInvalid
 */
export interface QuestionsAnswersInvalid {
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'msg'?: string;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof QuestionsAnswersInvalid
     */
    'invalidAnswers': { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersInvalid
     */
    'tooManyAnswers': boolean;
}
/**
 * 
 * @export
 * @interface QuestionsAuthCfg
 */
export interface QuestionsAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof QuestionsAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof QuestionsAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Transform user answer to lowercase letters. This allows user still pass a check when he wrote name or city with different cases. `false` means strict match, so \"John\" != \"john\"
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'lowercase'?: boolean;
    /**
     * Remove all non-letters from user answer.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSymbols'?: boolean;
    /**
     * Remove all spaces from user answer.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSpaces'?: boolean;
    /**
     * Min length of answer. Length are checked after all answer transformation.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'minLength'?: number;
    /**
     * Max length of answer.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxLength'?: number;
    /**
     * Min number of answers required to pass this check.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'answersRequired'?: number;
    /**
     * Max answers that user can save.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxAnswers'?: number;
}
/**
 * 
 * @export
 * @interface QuestionsAuthReqData
 */
export interface QuestionsAuthReqData {
    [key: string]: any;

    /**
     * Given answers for questions. 
     * @type {{ [key: string]: string; }}
     * @memberof QuestionsAuthReqData
     */
    'answers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QuestionsAuthResData
 */
export interface QuestionsAuthResData {
    [key: string]: any;

    /**
     * Shows is answer was correct. 
     * @type {{ [key: string]: boolean; }}
     * @memberof QuestionsAuthResData
     */
    'correct': { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface QuestionsPrivateData
 */
export interface QuestionsPrivateData {
    [key: string]: any;

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof QuestionsPrivateData
     */
    'answers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QuestionsPublicData
 */
export interface QuestionsPublicData {
    [key: string]: any;

    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof QuestionsPublicData
     */
    'answersSavedAt'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface QuestionsUpdateReqData
 */
export interface QuestionsUpdateReqData {
    [key: string]: any;

    /**
     * Answers to save. `null` as value removes answer 
     * @type {{ [key: string]: string; }}
     * @memberof QuestionsUpdateReqData
     */
    'answers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QuestionsUpdateResData
 */
export interface QuestionsUpdateResData {
    [key: string]: any;

    /**
     * Date of last update 
     * @type {{ [key: string]: number; }}
     * @memberof QuestionsUpdateResData
     */
    'answersSavedAt': { [key: string]: number; };
}
/**
 * Rate limiter configuration
 * @export
 * @interface RateLimiterCfg
 */
export interface RateLimiterCfg {
    /**
     * Create different rate limiters for different users.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'userId'?: boolean;
    /**
     * Create different rate limiters for different ips.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'ip'?: boolean;
    /**
     * Total quota available for time period. Quota means \"weight\" of a request. So quota 1.0 and period 1s allows 10 request with weight 0.1 per seconds or 5 request with weight 0.2 per second.
     * @type {number}
     * @memberof RateLimiterCfg
     */
    'quota'?: number;
    /**
     * Quota restoring period 
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'period'?: string;
    /**
     * Insert delays between requests if there are too many simultaneous requests.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'alignLoad'?: boolean;
    /**
     * Allows to combine rate limiters. Let\'s say rt1 allows 10 reqs per seconds, and rt2 allows 20 reqs per minute. If the rt1 has the rt2 as a parent, that means that rt1 allows 10 reqs per seconds but not more than 20 per minute.
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'parent'?: string;
}
/**
 * 
 * @export
 * @interface RateLimiterReq
 */
export interface RateLimiterReq {
    /**
     * 
     * @type {string}
     * @memberof RateLimiterReq
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof RateLimiterReq
     */
    'quotaToBurn': number;
}
/**
 * 
 * @export
 * @interface RedisCfg
 */
export interface RedisCfg {
    /**
     * 
     * @type {Array<string>}
     * @memberof RedisCfg
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'database'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'maxConnections'?: number;
}
/**
 * Long-living token used for generation of new access token. This is optional. You can set longer access-token lifetime instead.
 * @export
 * @interface RefreshTokenCfg
 */
export interface RefreshTokenCfg {
    /**
     * Lifetime for refresh token. 10d, 3M, etc. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'ttl'?: string;
    /**
     * Refresh token can be prolonged by refresh. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'maxTtl'?: string;
    /**
     * Lifetime of token for unauthenticated session. Limits time that user has to sign in/up, restoring password etc. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'unauthenticatedTtl'?: string;
    /**
     * If false - one refresh token can\'t be used twice. New refresh token will be provided by refresh API.
     * @type {boolean}
     * @memberof RefreshTokenCfg
     */
    'allowReuse'?: boolean;
}
/**
 * 
 * @export
 * @interface RefreshTokenReq
 */
export interface RefreshTokenReq {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenReq
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRes
 */
export interface RefreshTokenRes {
    /**
     * 
     * @type {Tokens}
     * @memberof RefreshTokenRes
     */
    'tokens': Tokens;
    /**
     * 
     * @type {Session}
     * @memberof RefreshTokenRes
     */
    'session': Session;
}
/**
 * Authentication implementation config
 * @export
 * @interface RemoteAuthCfg
 */
export interface RemoteAuthCfg {
    /**
     * Path to the API that implements plugin.
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'remote': string;
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof RemoteAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof RemoteAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof RemoteAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Add query params after `?` symbol in url. 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'query'?: { [key: string]: string; };
    /**
     * Add headers to request. 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof RemoteAuthCfg
     */
    'code'?: CodeCfg;
}
/**
 * 
 * @export
 * @interface RemoteDbCfg
 */
export interface RemoteDbCfg {
    /**
     * 
     * @type {string}
     * @memberof RemoteDbCfg
     */
    'remote': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'headers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SaveUserReq
 */
export interface SaveUserReq {
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof SaveUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SaveUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof SaveUserReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * 
     * @type {boolean}
     * @memberof SaveUserReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveUserRes
 */
export interface SaveUserRes {
    /**
     * 
     * @type {User}
     * @memberof SaveUserRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof SaveUserRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface ServerErr
 */
export interface ServerErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ServerErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof ServerErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof ServerErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServerErrCode = {
    ServerErr: 'SERVER_ERR',
    PluginErr: 'PLUGIN_ERR'
} as const;

export type ServerErrCode = typeof ServerErrCode[keyof typeof ServerErrCode];


/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * Entry that authenticates this session
     * @type {string}
     * @memberof Session
     */
    'entry': string;
    /**
     * Login used to identify this user
     * @type {Array<LoginId>}
     * @memberof Session
     */
    'identifiedBy': Array<LoginId>;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userId'?: string;
    /**
     * Authenticator used for factors 
     * @type {{ [key: string]: string; }}
     * @memberof Session
     */
    'authenticatedBy': { [key: string]: string; };
    /**
     * Auths that waiting for confirmation 
     * @type {{ [key: string]: UnconfirmedAuth; }}
     * @memberof Session
     */
    'unconfirmedAuths': { [key: string]: UnconfirmedAuth; };
    /**
     * List of factors needed to authenticate this session
     * @type {Array<NextFactor>}
     * @memberof Session
     */
    'nextFactors': Array<NextFactor>;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'signedInAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'expiresAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'refreshedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'newUser': boolean;
    /**
     * App services list that this session is allowed to access. Null if allowed to access any scope
     * @type {Array<string>}
     * @memberof Session
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device': Device;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'systemAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'expired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SessionExpired
 */
export interface SessionExpired {
    /**
     * 
     * @type {string}
     * @memberof SessionExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof SessionExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof SessionExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ShAppCfg
 */
export interface ShAppCfg {
    /**
     * 
     * @type {ShHttpCfg}
     * @memberof ShAppCfg
     */
    'http'?: ShHttpCfg;
    /**
     * Types of logins that can be used for identification.  If the login type is not specified in the auth config - it will be considered a simple login: the user can set any name. E.g. username.  If the login type is specified in the auth config, this login will be generated by the corresponding authenticator. E.g. email, phone or facebook account id.  
     * @type {Set<string>}
     * @memberof ShAppCfg
     */
    'logins'?: Set<string>;
    /**
     * Regexes to validate logins. 
     * @type {{ [key: string]: string; }}
     * @memberof ShAppCfg
     */
    'loginRequirements'?: { [key: string]: string; };
    /**
     * List of auth names and auth configs  To use builtin auths (not a plugin or remote) follow the example: `\"password\": { ... }` or `\"anyAuthName\": { \"builtin\": \"password\", ... }`  Available built-in auths: - `password`, `email`, `questions`, `ip` - `oauth`, `oauth/facebook/openid`, `oauth/google/openid` - `appSecret`  
     * @type {{ [key: string]: ShAppCfgAuthsValue; }}
     * @memberof ShAppCfg
     */
    'auths'?: { [key: string]: ShAppCfgAuthsValue; };
    /**
     * List of app entries. Entry usually represents UI used for signing in/up or additional authentication before action. E.g.: - app: main entry that requests user login/email + password and 2fa (if enabled) - api: entry that allows user to generate API keys and connect third-party app - action: additional authentication (e.g. code from sms) requested before e.g. payment 
     * @type {{ [key: string]: EntryCfg; }}
     * @memberof ShAppCfg
     */
    'entries'?: { [key: string]: EntryCfg; };
    /**
     * 
     * @type {ShDbsCfg}
     * @memberof ShAppCfg
     */
    'db'?: ShDbsCfg;
    /**
     * 
     * @type {TokenCfg}
     * @memberof ShAppCfg
     */
    'token'?: TokenCfg;
    /**
     * List of rate limiters 
     * @type {{ [key: string]: RateLimiterCfg; }}
     * @memberof ShAppCfg
     */
    'rateLimiters'?: { [key: string]: RateLimiterCfg; };
    /**
     * The key that app uses for RSA certificate generation used for token signature. If `null` - app will generate secret automatically during startup.
     * @type {string}
     * @memberof ShAppCfg
     */
    'secret'?: string;
    /**
     * Set this key if you want to restrict access to the health-check.
     * @type {string}
     * @memberof ShAppCfg
     */
    'healthCheckKey'?: string;
    /**
     * 
     * @type {I18nCfg}
     * @memberof ShAppCfg
     */
    'i18n'?: I18nCfg;
    /**
     * 
     * @type {string}
     * @memberof ShAppCfg
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface ShAppCfgAuthsValue
 */
export interface ShAppCfgAuthsValue {
    /**
     * Path to the API that implements plugin.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'remote'?: string;
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof ShAppCfgAuthsValue
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'burnQuota'?: number;
    /**
     * Add query params after `?` symbol in url. 
     * @type {{ [key: string]: string; }}
     * @memberof ShAppCfgAuthsValue
     */
    'query'?: { [key: string]: string; };
    /**
     * Add headers to request. 
     * @type {{ [key: string]: string; }}
     * @memberof ShAppCfgAuthsValue
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof ShAppCfgAuthsValue
     */
    'code'?: CodeCfg;
    /**
     * Email server address/IP.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'server'?: string;
    /**
     * Email address of sender.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'sender'?: string;
    /**
     * SMTP username.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'username'?: string;
    /**
     * SMTP password.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'password'?: string;
    /**
     * If not null, server will create template param `confirmationUrl` that will contain query parameters with confirmation code, session id, etc.
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'confirmationUrl'?: string;
    /**
     * List of email templates. Key - is name of a template (can be used lately on frontend), value - is path to the template. App uses handlebars templates to generate emails. See docs here https://handlebarsjs.com  Email templates receives `confirmationUrl`, `action`, `user`, `session`, `codeId`, `code`, `codeExpiresInMinutes`, `lang`, `headers` as template params, e.g. you can print user id as `{{user.id}}`.  Template engine also provides `i18n` helper for localisation. E.g. `{{i18n \'confirmationButton\' default=\'Confirm\'}}` searches key `confirmationButton` in files specified by `i18n.dir` config.  Use `{{err ERR_CODE msg=\'Localised message (if null, will be taken from i18n file)\' devMsg=\'dev message\'}}` to raise an error in a template.  It allows setting subject of email using `title` html tag, e.g. `<title>Email subject</title>`.  
     * @type {{ [key: string]: string; }}
     * @memberof ShAppCfgAuthsValue
     */
    'templates'?: { [key: string]: string; };
    /**
     * Additional params for templates that can be passed in request. Key - is a name of additional parameter, value - is a default value for this parameter (when no value present in request) 
     * @type {{ [key: string]: object; }}
     * @memberof ShAppCfgAuthsValue
     */
    'templateParams'?: { [key: string]: object; };
    /**
     * This allows to drop last bytes of IP. So it allows to authenticate factor when ip has rough match, e.g. the same country, same city, or same internet provider.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'ipBytesToIgnore'?: number;
    /**
     * History of IP addresses user used to sign-in. Authenticated when user attempts to sign in with one of stored IPs.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'historySize'?: number;
    /**
     * 
     * @type {OAuthCfgExchangeAuthCode}
     * @memberof ShAppCfgAuthsValue
     */
    'exchangeAuthCode'?: OAuthCfgExchangeAuthCode;
    /**
     * 
     * @type {OAuthCfgUserInfo}
     * @memberof ShAppCfgAuthsValue
     */
    'userInfo'?: OAuthCfgUserInfo;
    /**
     * Json path for login in the exchangeAuthCode or userInfo endpoint response. e.g. `access_token.user.id` extracts user login from `{ \"access_token\": { \"user\": { \"id\": \"...\" } } }` 
     * @type {string}
     * @memberof ShAppCfgAuthsValue
     */
    'extractLogin'?: string;
    /**
     * Can fill public data from the exchangeAuthCode or userInfo endpoint response. 
     * @type {{ [key: string]: string; }}
     * @memberof ShAppCfgAuthsValue
     */
    'extractPublicData'?: { [key: string]: string; };
    /**
     * Max length of answer.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'maxLength'?: number;
    /**
     * Min length of answer. Length are checked after all answer transformation.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'forbidLoginAsPassword'?: boolean;
    /**
     * 
     * @type {PasswordHistoryCfg}
     * @memberof ShAppCfgAuthsValue
     */
    'forbidReusingPassword'?: PasswordHistoryCfg;
    /**
     * Allows to calculate password strength based on mentioned criteria. Requirements will be checked one by one until first failed. 
     * @type {{ [key: string]: PasswordStrengthRequirements; }}
     * @memberof ShAppCfgAuthsValue
     */
    'strength'?: { [key: string]: PasswordStrengthRequirements; };
    /**
     * Transform user answer to lowercase letters. This allows user still pass a check when he wrote name or city with different cases. `false` means strict match, so \"John\" != \"john\"
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'lowercase'?: boolean;
    /**
     * Remove all non-letters from user answer.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'removeSymbols'?: boolean;
    /**
     * Remove all spaces from user answer.
     * @type {boolean}
     * @memberof ShAppCfgAuthsValue
     */
    'removeSpaces'?: boolean;
    /**
     * Min number of answers required to pass this check.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'answersRequired'?: number;
    /**
     * Max answers that user can save.
     * @type {number}
     * @memberof ShAppCfgAuthsValue
     */
    'maxAnswers'?: number;
}
/**
 * Database connection configs
 * @export
 * @interface ShDbsCfg
 */
export interface ShDbsCfg {
    /**
     * 
     * @type {ShDbsCfgUser}
     * @memberof ShDbsCfg
     */
    'user'?: ShDbsCfgUser;
    /**
     * 
     * @type {ShDbsCfgSession}
     * @memberof ShDbsCfg
     */
    'session'?: ShDbsCfgSession;
    /**
     * 
     * @type {ShDbsCfgRateLimiter}
     * @memberof ShDbsCfg
     */
    'rateLimiter'?: ShDbsCfgRateLimiter;
}
/**
 * Database for rate-limiters. If you don\'t use rate-limiter leave this empty (`{}`).
 * @export
 * @interface ShDbsCfgRateLimiter
 */
export interface ShDbsCfgRateLimiter {
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgRateLimiter
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgRateLimiter
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgRateLimiter
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShDbsCfgRateLimiter
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgRateLimiter
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgRateLimiter
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgRateLimiter
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgRateLimiter
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgRateLimiter
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgRateLimiter
     */
    'sqlite'?: string;
}
/**
 * Session database config.  If you aren\'t using cluster, prefer in-memory database.  You can use in-token to not use database at all. Use it with `token.access.cacheUnauthenticated = true` and `token.access.cache != null` values.
 * @export
 * @interface ShDbsCfgSession
 */
export interface ShDbsCfgSession {
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgSession
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgSession
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgSession
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShDbsCfgSession
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgSession
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgSession
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgSession
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgSession
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgSession
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgSession
     */
    'sqlite'?: string;
}
/**
 * User database config
 * @export
 * @interface ShDbsCfgUser
 */
export interface ShDbsCfgUser {
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgUser
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgUser
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgUser
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShDbsCfgUser
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgUser
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShDbsCfgUser
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ShDbsCfgUser
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgUser
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ShDbsCfgUser
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShDbsCfgUser
     */
    'sqlite'?: string;
}
/**
 * Http server config
 * @export
 * @interface ShHttpCfg
 */
export interface ShHttpCfg {
    /**
     * A port that the server will use to accept http requests 
     * @type {number}
     * @memberof ShHttpCfg
     */
    'port'?: number;
    /**
     * IP address to bind to. Usually 0.0.0.0 to accept for any connection or 127.0.0.1 to accept only localhost 
     * @type {string}
     * @memberof ShHttpCfg
     */
    'bind'?: string;
    /**
     * If true, X-Forwarded-For header is used to get client\'s IP address
     * @type {boolean}
     * @memberof ShHttpCfg
     */
    'proxy'?: boolean;
}
/**
 * 
 * @export
 * @interface SignatureIsIncorrect
 */
export interface SignatureIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SkippedAuthExecRes
 */
export interface SkippedAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof SkippedAuthExecRes
     */
    'status': SkippedAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof SkippedAuthExecRes
     */
    'sentCode'?: Code;
}

export const SkippedAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type SkippedAuthExecResStatusEnum = typeof SkippedAuthExecResStatusEnum[keyof typeof SkippedAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface SqliteCfg
 */
export interface SqliteCfg {
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqliteCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'sqlite'?: string;
}
/**
 * Token lifetime config.
 * @export
 * @interface TokenCfg
 */
export interface TokenCfg {
    /**
     * 
     * @type {AccessTokenCfg}
     * @memberof TokenCfg
     */
    'access'?: AccessTokenCfg;
    /**
     * 
     * @type {RefreshTokenCfg}
     * @memberof TokenCfg
     */
    'refresh'?: RefreshTokenCfg;
    /**
     * Require all request to be made from the same device.
     * @type {boolean}
     * @memberof TokenCfg
     */
    'sameUserAgent'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenExpired
 */
export interface TokenExpired {
    /**
     * 
     * @type {string}
     * @memberof TokenExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof TokenExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof TokenExpired
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenExpired
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @interface TokenHandlerCfg
 */
export interface TokenHandlerCfg {
    /**
     * If access token provided in request, app tries to extract user id from user-info endpoint. If null, user info will be extracted from access token 
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'url'?: string;
    /**
     * While executing user-info request, access-token will be sent in query param.
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInQuery'?: string;
    /**
     * While executing user-info request, access-token will be sent in Authorisation header.
     * @type {boolean}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInHeader'?: boolean;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * Access token for authentication
     * @type {string}
     * @memberof Tokens
     */
    'access': string;
    /**
     * Refresh token for obtaining new access token
     * @type {string}
     * @memberof Tokens
     */
    'refresh': string;
    /**
     * 
     * @type {number}
     * @memberof Tokens
     */
    'accessTokenExpiresAt'?: number;
}
/**
 * 
 * @export
 * @interface TooManyReqs
 */
export interface TooManyReqs {
    /**
     * 
     * @type {string}
     * @memberof TooManyReqs
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof TooManyReqs
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof TooManyReqs
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeMinutes'?: number;
}
/**
 * 
 * @export
 * @interface Unauthenticated
 */
export interface Unauthenticated {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof Unauthenticated
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof Unauthenticated
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Unauthenticated
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UnauthenticatedCode = {
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    TokenExpired: 'TOKEN_EXPIRED',
    Unauthenticated: 'UNAUTHENTICATED'
} as const;

export type UnauthenticatedCode = typeof UnauthenticatedCode[keyof typeof UnauthenticatedCode];


/**
 * 
 * @export
 * @interface UnconfirmedAuth
 */
export interface UnconfirmedAuth {
    /**
     * 
     * @type {Array<CodeVerifier>}
     * @memberof UnconfirmedAuth
     */
    'sentCodes'?: Array<CodeVerifier>;
}
/**
 * 
 * @export
 * @interface UnconfirmedAuthData
 */
export interface UnconfirmedAuthData {
    /**
     * 
     * @type {AuthData}
     * @memberof UnconfirmedAuthData
     */
    'data': AuthData;
    /**
     * 
     * @type {CodeVerifier}
     * @memberof UnconfirmedAuthData
     */
    'code': CodeVerifier;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Generated user uuid 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {Array<Login>}
     * @memberof User
     */
    'logins': Array<Login>;
    /**
     * Public data of confirmed auths and sent codes for unconfirmed auths. 
     * @type {{ [key: string]: AuthUserCfg; }}
     * @memberof User
     */
    'auths': { [key: string]: AuthUserCfg; };
    /**
     * Enabled factors
     * @type {Set<string>}
     * @memberof User
     */
    'factors': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'signedUpAt': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'new'?: boolean;
    /**
     * Allows to edit any user in the app.
     * @type {boolean}
     * @memberof User
     */
    'systemAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface UserLoginAlreadyTaken
 */
export interface UserLoginAlreadyTaken {
    /**
     * 
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface UserLoginIsInvalid
 */
export interface UserLoginIsInvalid {
    /**
     * 
     * @type {string}
     * @memberof UserLoginIsInvalid
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof UserLoginIsInvalid
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof UserLoginIsInvalid
     */
    'msg'?: string;
    /**
     * 
     * @type {LoginId}
     * @memberof UserLoginIsInvalid
     */
    'loginId': LoginId;
}
/**
 * 
 * @export
 * @interface UserNotFound
 */
export interface UserNotFound {
    /**
     * 
     * @type {string}
     * @memberof UserNotFound
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof UserNotFound
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof UserNotFound
     */
    'msg'?: string;
}

/**
 * AuthorisationApi - axios parameter creator
 * @export
 */
export const AuthorisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @summary (Backend API) authorize session
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (authorizeReq: AuthorizeReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizeReq' is not null or undefined
            assertParamExists('authorize', 'authorizeReq', authorizeReq)
            const localVarPath = `/api/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizeReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @summary (Backend API) validate by rate-limiter
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit: async (rateLimiterReq: RateLimiterReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateLimiterReq' is not null or undefined
            assertParamExists('limit', 'rateLimiterReq', rateLimiterReq)
            const localVarPath = `/api/rate-limiter/limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateLimiterReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorisationApi - functional programming interface
 * @export
 */
export const AuthorisationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorisationApiAxiosParamCreator(configuration)
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @summary (Backend API) authorize session
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(authorizeReq: AuthorizeReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(authorizeReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @summary (Backend API) validate by rate-limiter
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limit(rateLimiterReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorisationApi - factory interface
 * @export
 */
export const AuthorisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorisationApiFp(configuration)
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @summary (Backend API) authorize session
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(authorizeReq: AuthorizeReq, options?: any): AxiosPromise<AuthorizeRes> {
            return localVarFp.authorize(authorizeReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @summary (Backend API) validate by rate-limiter
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit(rateLimiterReq: RateLimiterReq, options?: any): AxiosPromise<AuthorizeRes> {
            return localVarFp.limit(rateLimiterReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorisationApi - object-oriented interface
 * @export
 * @class AuthorisationApi
 * @extends {BaseAPI}
 */
export class AuthorisationApi extends BaseAPI {
    /**
     * Validates token and executes rate limiter. This API should be called by backend. 
     * @summary (Backend API) authorize session
     * @param {AuthorizeReq} authorizeReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public authorize(authorizeReq: AuthorizeReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).authorize(authorizeReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
     * @summary (Backend API) validate by rate-limiter
     * @param {RateLimiterReq} rateLimiterReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).limit(rateLimiterReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @summary Server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/cfg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get server configuration. 
         * @summary Public server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfgPublic: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/cfg/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get server plugins state 
         * @summary Server health status
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @summary Server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfg(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShAppCfg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfg(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get server configuration. 
         * @summary Public server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfgPublic(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicCfgRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfgPublic(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get server plugins state 
         * @summary Server health status
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @summary Server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg(options?: any): AxiosPromise<ShAppCfg> {
            return localVarFp.cfg(options).then((request) => request(axios, basePath));
        },
        /**
         * Get server configuration. 
         * @summary Public server configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfgPublic(options?: any): AxiosPromise<PublicCfgRes> {
            return localVarFp.cfgPublic(options).then((request) => request(axios, basePath));
        },
        /**
         * Get server plugins state 
         * @summary Server health status
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(key?: string, options?: any): AxiosPromise<HealthRes> {
            return localVarFp.health(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Current server configuration. Available only for users with system-access. 
     * @summary Server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public cfg(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).cfg(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get server configuration. 
     * @summary Public server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public cfgPublic(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).cfgPublic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get server plugins state 
     * @summary Server health status
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public health(key?: string, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).health(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate session
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateReq: AuthenticateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateReq' is not null or undefined
            assertParamExists('authenticate', 'authenticateReq', authenticateReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @summary Confirm with code
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths: async (confirmSessionAuthsReq: ConfirmSessionAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmSessionAuthsReq' is not null or undefined
            assertParamExists('confirmSessionAuths', 'confirmSessionAuthsReq', confirmSessionAuthsReq)
            const localVarPath = `/api/session/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSessionAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign out another session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delSession: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('delSession', 'sessionId', sessionId)
            const localVarPath = `/api/session/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List sessions
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (entry?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entry !== undefined) {
                localVarQueryParameter['entry'] = entry;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current session data. 
         * @summary Get session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @summary New session
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession: async (newSessionReq: NewSessionReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newSessionReq' is not null or undefined
            assertParamExists('newSession', 'newSessionReq', newSessionReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSessionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign out current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authenticate session
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @summary Confirm with code
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSessionAuths(confirmSessionAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign out another session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delSession(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delSession(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List sessions
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(entry?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSessionsRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(entry, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current session data. 
         * @summary Get session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @summary New session
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newSession(newSessionReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sign out current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @summary Authenticate session
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateReq: AuthenticateReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.authenticate(authenticateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @summary Confirm with code
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign out another session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delSession(sessionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.delSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List sessions
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(entry?: string, userId?: string, options?: any): AxiosPromise<FindSessionsRes> {
            return localVarFp.getAll(entry, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current session data. 
         * @summary Get session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @summary New session
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(newSessionReq: NewSessionReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.newSession(newSessionReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign out current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut(options?: any): AxiosPromise<object> {
            return localVarFp.signOut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @summary Authenticate session
     * @param {AuthenticateReq} authenticateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).authenticate(authenticateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
     * @summary Confirm with code
     * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign out another session
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public delSession(sessionId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).delSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List sessions
     * @param {string} [entry] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAll(entry?: string, userId?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getAll(entry, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current session data. 
     * @summary Get session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSession(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new session. if session entry requires another entry, access token must be provided. 
     * @summary New session
     * @param {NewSessionReq} newSessionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).newSession(newSessionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign out current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public signOut(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).signOut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignatureApi - axios parameter creator
 * @export
 */
export const SignatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public key generated from app-secret from config used for signature validation. 
         * @summary Get RSA public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/signature/public-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign data using specified secret. When secret is null - use app secret (specified in kntrl.json5) with SHA256withRSA algorithm. Otherwise - use secret from query with HmacSHA256 algorithm. 
         * @summary (Backend API) sign data
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sign', 'body', body)
            const localVarPath = `/api/signature/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates data signature. See /sign API for details. 
         * @summary Validate signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (signature: string, body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('verify', 'signature', signature)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('verify', 'body', body)
            const localVarPath = `/api/signature/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignatureApi - functional programming interface
 * @export
 */
export const SignatureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignatureApiAxiosParamCreator(configuration)
    return {
        /**
         * Public key generated from app-secret from config used for signature validation. 
         * @summary Get RSA public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign data using specified secret. When secret is null - use app secret (specified in kntrl.json5) with SHA256withRSA algorithm. Otherwise - use secret from query with HmacSHA256 algorithm. 
         * @summary (Backend API) sign data
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates data signature. See /sign API for details. 
         * @summary Validate signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(signature, body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignatureApi - factory interface
 * @export
 */
export const SignatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignatureApiFp(configuration)
    return {
        /**
         * Public key generated from app-secret from config used for signature validation. 
         * @summary Get RSA public key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any): AxiosPromise<string> {
            return localVarFp.getPublicKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Sign data using specified secret. When secret is null - use app secret (specified in kntrl.json5) with SHA256withRSA algorithm. Otherwise - use secret from query with HmacSHA256 algorithm. 
         * @summary (Backend API) sign data
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(body: string, secret?: string, options?: any): AxiosPromise<string> {
            return localVarFp.sign(body, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates data signature. See /sign API for details. 
         * @summary Validate signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(signature: string, body: string, secret?: string, options?: any): AxiosPromise<void> {
            return localVarFp.verify(signature, body, secret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignatureApi - object-oriented interface
 * @export
 * @class SignatureApi
 * @extends {BaseAPI}
 */
export class SignatureApi extends BaseAPI {
    /**
     * Public key generated from app-secret from config used for signature validation. 
     * @summary Get RSA public key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public getPublicKey(options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).getPublicKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign data using specified secret. When secret is null - use app secret (specified in kntrl.json5) with SHA256withRSA algorithm. Otherwise - use secret from query with HmacSHA256 algorithm. 
     * @summary (Backend API) sign data
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public sign(body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).sign(body, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates data signature. See /sign API for details. 
     * @summary Validate signature
     * @param {string} signature 
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).verify(signature, body, secret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get new access token using refresh token. 
         * @summary Refresh access token
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenReq: RefreshTokenReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenReq' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenReq', refreshTokenReq)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Get new access token using refresh token. 
         * @summary Refresh access token
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Get new access token using refresh token. 
         * @summary Refresh access token
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenReq: RefreshTokenReq, options?: any): AxiosPromise<RefreshTokenRes> {
            return localVarFp.refreshToken(refreshTokenReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Get new access token using refresh token. 
     * @summary Refresh access token
     * @param {RefreshTokenReq} refreshTokenReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig) {
        return TokenApiFp(this.configuration).refreshToken(refreshTokenReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Confirm enabled auth
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths: async (confirmUserAuthsReq: ConfirmUserAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmUserAuthsReq' is not null or undefined
            assertParamExists('confirmUserAuths', 'confirmUserAuthsReq', confirmUserAuthsReq)
            const localVarPath = `/api/user/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmUserAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Admin API) Edit user
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (id: string, editUserReq: EditUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUser', 'id', id)
            // verify required parameter 'editUserReq' is not null or undefined
            assertParamExists('editUser', 'editUserReq', editUserReq)
            const localVarPath = `/api/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves users. Be careful with order. To avoid potential \"duplicated entry\" problem, remove operation goes firs, then update, then insert. 
         * @summary Save user
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (saveUserReq: SaveUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveUserReq' is not null or undefined
            assertParamExists('saveUser', 'saveUserReq', saveUserReq)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Confirm enabled auth
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmUserAuths(confirmUserAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary (Admin API) Edit user
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(id, editUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Saves users. Be careful with order. To avoid potential \"duplicated entry\" problem, remove operation goes firs, then update, then insert. 
         * @summary Save user
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(saveUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Confirm enabled auth
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Admin API) Edit user
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(id: string, editUserReq: EditUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.editUser(id, editUserReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Saves users. Be careful with order. To avoid potential \"duplicated entry\" problem, remove operation goes firs, then update, then insert. 
         * @summary Save user
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(saveUserReq: SaveUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.saveUser(saveUserReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Confirm enabled auth
     * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary (Admin API) Edit user
     * @param {string} id 
     * @param {EditUserReq} editUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(id, editUserReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves users. Be careful with order. To avoid potential \"duplicated entry\" problem, remove operation goes firs, then update, then insert. 
     * @summary Save user
     * @param {SaveUserReq} saveUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).saveUser(saveUserReq, options).then((request) => request(this.axios, this.basePath));
    }
}


