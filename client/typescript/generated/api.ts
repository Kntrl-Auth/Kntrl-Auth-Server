/* tslint:disable */
/* eslint-disable */
/**
 * Kntrl API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessDenied
 */
export interface AccessDenied {
    /**
     * 
     * @type {string}
     * @memberof AccessDenied
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AccessDenied
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AccessDenied
     */
    'msg'?: string;
}
/**
 * Short-living token used for authentication.
 * @export
 * @interface AccessTokenCfg
 */
export interface AccessTokenCfg {
    /**
     * Send token in `access_token` cookie
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cookie'?: boolean;
    /**
     * 
     * @type {Cache}
     * @memberof AccessTokenCfg
     */
    'cache'?: Cache;
    /**
     * By default, unauthenticated sessions can\'t be cached.
     * @type {boolean}
     * @memberof AccessTokenCfg
     */
    'cacheUnauthenticated'?: boolean;
    /**
     * Lifetime for access token. 1d, 30m, etc. 
     * @type {string}
     * @memberof AccessTokenCfg
     */
    'ttl'?: string;
}
/**
 * 
 * @export
 * @interface AnswerErr
 */
export interface AnswerErr {
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerErr
     */
    'tooLong': boolean;
}
/**
 * 
 * @export
 * @interface AnyErr
 */
export interface AnyErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AnyErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AnyErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AnyErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AppSecretAuthCfg
 */
export interface AppSecretAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof AppSecretAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof AppSecretAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof AppSecretAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof AppSecretAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AppSecretReq
 */
export interface AppSecretReq {
    /**
     * 
     * @type {string}
     * @memberof AppSecretReq
     */
    'secret': string;
}
/**
 * Authentication implementation config
 * @export
 * @interface AuthCfg
 */
export interface AuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof AuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof AuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof AuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof AuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @interface AuthCodeHandlerCfg
 */
export interface AuthCodeHandlerCfg {
    /**
     * Url to get access token by authorisation code.
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'tokenUrl': string;
    /**
     * OAuth client id. Client must be registered on OAuth provider (e.g. facebook, google)
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'clientId': string;
    /**
     * OAuth client secret.
     * @type {string}
     * @memberof AuthCodeHandlerCfg
     */
    'clientSecret'?: string;
}
/**
 * 
 * @export
 * @interface AuthData
 */
export interface AuthData {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AuthData
     */
    'public': { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof AuthData
     */
    'login'?: string;
}
/**
 * 
 * @export
 * @interface AuthExecRes
 */
export interface AuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof AuthExecRes
     */
    'status': AuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof AuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {Err}
     * @memberof AuthExecRes
     */
    'err'?: Err;
    /**
     * 
     * @type {AuthExecResResData}
     * @memberof AuthExecRes
     */
    'resData'?: AuthExecResResData;
}

export const AuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type AuthExecResStatusEnum = typeof AuthExecResStatusEnum[keyof typeof AuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface AuthExecResResData
 */
export interface AuthExecResResData {
    [key: string]: any;

    /**
     * Shows user email, that was used to send a code. Email will be partially hidden.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'emailSentTo'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthExecResResData
     */
    'ipEncoded'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthExecResResData
     */
    'login'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AuthExecResResData
     */
    'publicData'?: { [key: string]: object; };
    /**
     * If password was generated by app this field contains generated password.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'password'?: string;
    /**
     * Calculated strength of password. Null means that all checks failed.
     * @type {string}
     * @memberof AuthExecResResData
     */
    'strength'?: string;
    /**
     * Shows is answer was correct. 
     * @type {{ [key: string]: boolean; }}
     * @memberof AuthExecResResData
     */
    'correct'?: { [key: string]: boolean; };
    /**
     * Date of last update
     * @type {{ [key: string]: number; }}
     * @memberof AuthExecResResData
     */
    'answersSavedAt'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface AuthIsNotConfirmed
 */
export interface AuthIsNotConfirmed {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthIsNotConfirmed
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthIsNotEnabled
 */
export interface AuthIsNotEnabled {
    /**
     * 
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthIsNotEnabled
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthRequiresAnother
 */
export interface AuthRequiresAnother {
    /**
     * 
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof AuthRequiresAnother
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface AuthUserCfg
 */
export interface AuthUserCfg {
    /**
     * 
     * @type {AuthData}
     * @memberof AuthUserCfg
     */
    'data'?: AuthData;
    /**
     * List of auths that wait for confirmation. 
     * @type {Array<UnconfirmedAuthData>}
     * @memberof AuthUserCfg
     */
    'sentCodes'?: Array<UnconfirmedAuthData>;
    /**
     * 
     * @type {boolean}
     * @memberof AuthUserCfg
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateReq
 */
export interface AuthenticateReq {
    /**
     * Forces specific auth to be used for factor. Takes place only when multiple auths is provided within request and auth can be assigned to several factors. If used in sign-up mode, it just enables those factors. 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticateReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * Request for authenticators 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof AuthenticateReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * Execute only validation ща authenticator requests.
     * @type {boolean}
     * @memberof AuthenticateReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateReqAuthReqsValue
 */
export interface AuthenticateReqAuthReqsValue {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'secret'?: string;
    /**
     * New email to set.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'email'?: string;
    /**
     * Template to use.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'template'?: string;
    /**
     * If you have access-token - put it here.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'accessToken'?: string;
    /**
     * If you have authorisation-code - app will exchange it for access-token.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'authorizationCode'?: string;
    /**
     * New password to set. If null app generates password automatically.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'password'?: string;
    /**
     * Password confirmation. If null app doesn\'t perform this check.
     * @type {string}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'confirmPassword'?: string;
    /**
     * Answers to save. `null` as value removes answer 
     * @type {{ [key: string]: string; }}
     * @memberof AuthenticateReqAuthReqsValue
     */
    'answers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AuthenticateRes
 */
export interface AuthenticateRes {
    /**
     * 
     * @type {Tokens}
     * @memberof AuthenticateRes
     */
    'tokens'?: Tokens;
    /**
     * 
     * @type {Session}
     * @memberof AuthenticateRes
     */
    'session'?: Session;
    /**
     * 
     * @type {User}
     * @memberof AuthenticateRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof AuthenticateRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface AuthorizeReq
 */
export interface AuthorizeReq {
    /**
     * 
     * @type {RateLimiterReq}
     * @memberof AuthorizeReq
     */
    'rateLimiter'?: RateLimiterReq;
}
/**
 * 
 * @export
 * @interface AuthorizeRes
 */
export interface AuthorizeRes {
    /**
     * 
     * @type {Session}
     * @memberof AuthorizeRes
     */
    'session'?: Session;
}
/**
 * Authentication implementation config
 * @export
 * @interface BuiltInAuthCfg
 */
export interface BuiltInAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof BuiltInAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof BuiltInAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof BuiltInAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof BuiltInAuthCfg
     */
    'burnQuota'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Cache = {
    Jwt: 'JWT',
    Binary: 'BINARY'
} as const;

export type Cache = typeof Cache[keyof typeof Cache];


/**
 * 
 * @export
 * @interface ClientErr
 */
export interface ClientErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof ClientErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof ClientErr
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'changedDaysAgo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooLong'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooShort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'missingLowerCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'commonPassword'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof ClientErr
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'passwordsMismatch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientErr
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'wasUsedDaysAgo'?: number;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ClientErr
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientErr
     */
    'incorrectAnswers'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'requiresMoreAnswers'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientErr
     */
    'questionsNotFound'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof ClientErr
     */
    'invalidAnswers'?: { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof ClientErr
     */
    'tooManyAnswers'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'waitTimeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClientErr
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ClientErrCode = {
    PluginClientErr: 'PLUGIN_CLIENT_ERR',
    PasswordIsIncorrect: 'PASSWORD_IS_INCORRECT',
    PasswordIsInvalid: 'PASSWORD_IS_INVALID',
    EmailIsIncorrect: 'EMAIL_IS_INCORRECT',
    IpNew: 'IP_NEW',
    QuestionsAnswersIncorrect: 'QUESTIONS_ANSWERS_INCORRECT',
    QuestionsAnswersInvalid: 'QUESTIONS_ANSWERS_INVALID',
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    SignatureIsIncorrect: 'SIGNATURE_IS_INCORRECT',
    UserLoginAlreadyTaken: 'USER_LOGIN_ALREADY_TAKEN',
    AuthIsNotEnabled: 'AUTH_IS_NOT_ENABLED',
    TokenExpired: 'TOKEN_EXPIRED',
    TooManyReqs: 'TOO_MANY_REQS',
    AuthIsNotConfirmed: 'AUTH_IS_NOT_CONFIRMED',
    AuthRequiresAnother: 'AUTH_REQUIRES_ANOTHER',
    CodeIsExpired: 'CODE_IS_EXPIRED',
    CodeTooManyAttempts: 'CODE_TOO_MANY_ATTEMPTS',
    CodeIsIncorrect: 'CODE_IS_INCORRECT',
    Unauthenticated: 'UNAUTHENTICATED'
} as const;

export type ClientErrCode = typeof ClientErrCode[keyof typeof ClientErrCode];


/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof Code
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Code
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * If specified - app generates code and requires auth to be confirmed
 * @export
 * @interface CodeCfg
 */
export interface CodeCfg {
    /**
     * Length of code to be generated
     * @type {number}
     * @memberof CodeCfg
     */
    'length'?: number;
    /**
     * Generated code lifetime. e.g. 1m, 60s, 1d, etc.
     * @type {string}
     * @memberof CodeCfg
     */
    'ttl'?: string;
    /**
     * Symbols used to generate a code. By default `a-z + A-Z + 0-9`.
     * @type {string}
     * @memberof CodeCfg
     */
    'alphabet'?: string;
    /**
     * If true, every second letter will be the same, that allows the codes to rhyme.
     * @type {boolean}
     * @memberof CodeCfg
     */
    'easyToRemember'?: boolean;
    /**
     * Max attempts to enter the code.
     * @type {number}
     * @memberof CodeCfg
     */
    'maxAttempts'?: number;
}
/**
 * 
 * @export
 * @interface CodeIsExpired
 */
export interface CodeIsExpired {
    /**
     * 
     * @type {string}
     * @memberof CodeIsExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeIsExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeIsExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeIsIncorrect
 */
export interface CodeIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeTooManyAttempts
 */
export interface CodeTooManyAttempts {
    /**
     * 
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof CodeTooManyAttempts
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CodeVerifier
 */
export interface CodeVerifier {
    /**
     * 
     * @type {string}
     * @memberof CodeVerifier
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'validUntil': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'usedAttempts': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'attemptsLeft': number;
    /**
     * 
     * @type {number}
     * @memberof CodeVerifier
     */
    'sentAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof CodeVerifier
     */
    'hasAttemptsLeft'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfirmSessionAuthsReq
 */
export interface ConfirmSessionAuthsReq {
    /**
     * 
     * @type {string}
     * @memberof ConfirmSessionAuthsReq
     */
    'sessionId'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmSessionAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface ConfirmUserAuthsReq
 */
export interface ConfirmUserAuthsReq {
    /**
     * 
     * @type {string}
     * @memberof ConfirmUserAuthsReq
     */
    'userId'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof ConfirmUserAuthsReq
     */
    'receivedCodes': { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface DbHealthRes
 */
export interface DbHealthRes {
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'user': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'session': HealthStatusRes;
    /**
     * 
     * @type {HealthStatusRes}
     * @memberof DbHealthRes
     */
    'rateLimiter': HealthStatusRes;
}
/**
 * Database connection configs
 * @export
 * @interface DbsCfg
 */
export interface DbsCfg {
    /**
     * 
     * @type {DbsCfgUser}
     * @memberof DbsCfg
     */
    'user': DbsCfgUser;
    /**
     * 
     * @type {DbsCfgSession}
     * @memberof DbsCfg
     */
    'session': DbsCfgSession;
    /**
     * 
     * @type {DbsCfgRateLimiter}
     * @memberof DbsCfg
     */
    'rateLimiter': DbsCfgRateLimiter;
}
/**
 * Database for rate-limiters. If you don\'t use rate-limiter leave this empty (`{}`).
 * @export
 * @interface DbsCfgRateLimiter
 */
export interface DbsCfgRateLimiter {
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgRateLimiter
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgRateLimiter
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgRateLimiter
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbsCfgRateLimiter
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgRateLimiter
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgRateLimiter
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgRateLimiter
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgRateLimiter
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgRateLimiter
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgRateLimiter
     */
    'sqlite'?: string;
}
/**
 * Session database config.  If you aren\'t using cluster, prefer in-memory database.  You can use in-token to not use database at all. Use it with `token.access.cacheUnauthenticated = true` and `token.access.cache != null` values.
 * @export
 * @interface DbsCfgSession
 */
export interface DbsCfgSession {
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgSession
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgSession
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgSession
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbsCfgSession
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgSession
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgSession
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgSession
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgSession
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgSession
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgSession
     */
    'sqlite'?: string;
}
/**
 * User database config
 * @export
 * @interface DbsCfgUser
 */
export interface DbsCfgUser {
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgUser
     */
    'inMemory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgUser
     */
    'inToken'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'mongodb'?: string;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgUser
     */
    'database'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbsCfgUser
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgUser
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbsCfgUser
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DbsCfgUser
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'remote'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgUser
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DbsCfgUser
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof DbsCfgUser
     */
    'sqlite'?: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'mobile': boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'userAgent': string;
}
/**
 * 
 * @export
 * @interface EditUserReq
 */
export interface EditUserReq {
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof EditUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EditUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof EditUserReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'dryRun'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EditUserReq
     */
    'systemAccess'?: boolean;
}
/**
 * 
 * @export
 * @interface EmailAuthCfg
 */
export interface EmailAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof EmailAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof EmailAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof EmailAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Email server address/IP.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'server': string;
    /**
     * Email address of sender.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'sender': string;
    /**
     * SMTP username.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'username'?: string;
    /**
     * SMTP password.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'password'?: string;
    /**
     * If not null, server will create template param `confirmationUrl` that will contain query parameters with confirmation code, session id, etc.
     * @type {string}
     * @memberof EmailAuthCfg
     */
    'confirmationUrl'?: string;
    /**
     * List of email templates. Key - name of template (can be used lately on frontend), value - path to template. App uses handlebars templates to generate emails. See docs here https://handlebarsjs.com  Email templates received `confirmationUrl`, `action`, `user`, `session`, `codeId`, `code`, `lang`, `headers` as template params, e.g. you can print user id as `{{ user.id }}`.  Template engine also provides `i18n` helper for localisation. E.g. `{{i18n \'confirmationButton\' default=\'Confirm\'}}` searches key `confirmationButton` in files specified by `i18n.dir` config.  It allows setting subject of email using `title` html tag, e.g. `<title>Email subject</title>`.  
     * @type {{ [key: string]: string; }}
     * @memberof EmailAuthCfg
     */
    'templates'?: { [key: string]: string; };
    /**
     * Additional params for template. 
     * @type {{ [key: string]: string; }}
     * @memberof EmailAuthCfg
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof EmailAuthCfg
     */
    'code'?: CodeCfg;
}
/**
 * 
 * @export
 * @interface EmailAuthRes
 */
export interface EmailAuthRes {
    /**
     * Shows user email, that was used to send a code. Email will be partially hidden.
     * @type {string}
     * @memberof EmailAuthRes
     */
    'emailSentTo'?: string;
}
/**
 * 
 * @export
 * @interface EmailAuthenticateReq
 */
export interface EmailAuthenticateReq {
    /**
     * User email. If email is not null - auth allow identification by email (email auth also must be listed in logins config). Otherwise, uses email of already identified user.
     * @type {string}
     * @memberof EmailAuthenticateReq
     */
    'email'?: string;
    /**
     * Template to use.
     * @type {string}
     * @memberof EmailAuthenticateReq
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface EmailIsIncorrect
 */
export interface EmailIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof EmailIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EmailUpdateReq
 */
export interface EmailUpdateReq {
    /**
     * New email to set.
     * @type {string}
     * @memberof EmailUpdateReq
     */
    'email': string;
    /**
     * Template to use.
     * @type {string}
     * @memberof EmailUpdateReq
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface EntryAccessTokenCfg
 */
export interface EntryAccessTokenCfg {
    /**
     * Override access token ttl
     * @type {string}
     * @memberof EntryAccessTokenCfg
     */
    'ttl'?: string;
    /**
     * Enable or disable client-side caching of access token
     * @type {boolean}
     * @memberof EntryAccessTokenCfg
     */
    'cache'?: boolean;
}
/**
 * Configuration for app entry.
 * @export
 * @interface EntryCfg
 */
export interface EntryCfg {
    /**
     * Specifies factors that always required to be authenticated.  Usually it\'s main auth method (e.g. password) + social login (e.g. facebook) + reserve auth option in case of lost/forgotten main auth credentials (e.g. secret questions or email auth).  These factors are always required even when user hasn\'t enabled them explicitly.  
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsRequired'?: { [key: string]: Array<string>; };
    /**
     * This factors can be skipped if user hasn\'t enabled them. Used for optional 2FA. E.g. If user added mobile phone -> use it for 2FA otherwise skip 2FA. 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof EntryCfg
     */
    'factorsOptional'?: { [key: string]: Array<string>; };
    /**
     * Require user to be already signed in by one of the listed entries. Usually it used for action confirmation, e.g. \"payment\" that requires confirmation by sms, requires user to be already signed in (e.g. with entry \"app\".
     * @type {Array<string>}
     * @memberof EntryCfg
     */
    'requiresEntry'?: Array<string>;
    /**
     * 
     * @type {EntryAccessTokenCfg}
     * @memberof EntryCfg
     */
    'accessToken'?: EntryAccessTokenCfg;
    /**
     * Max lifetime of session. 
     * @type {string}
     * @memberof EntryCfg
     */
    'ttl'?: string;
    /**
     * Is this session allowed to add/remove new auth, enable/disable factors, etc.?
     * @type {boolean}
     * @memberof EntryCfg
     */
    'editAccount'?: boolean;
}
/**
 * 
 * @export
 * @interface Err
 */
export interface Err {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof Err
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof Err
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'changedDaysAgo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooLong'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooShort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingSymbol'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingUpperCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'missingLowerCase'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'commonPassword'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof Err
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'passwordsMismatch'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Err
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'wasUsedDaysAgo'?: number;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Err
     */
    'data'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Err
     */
    'incorrectAnswers'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'requiresMoreAnswers'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Err
     */
    'questionsNotFound'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof Err
     */
    'invalidAnswers'?: { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof Err
     */
    'tooManyAnswers'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'waitTimeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Err
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @interface ErrAuthExecRes
 */
export interface ErrAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof ErrAuthExecRes
     */
    'status': ErrAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof ErrAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {Err}
     * @memberof ErrAuthExecRes
     */
    'err': Err;
}

export const ErrAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type ErrAuthExecResStatusEnum = typeof ErrAuthExecResStatusEnum[keyof typeof ErrAuthExecResStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ErrCode = {
    PluginErr: 'PLUGIN_ERR',
    PluginClientErr: 'PLUGIN_CLIENT_ERR',
    PasswordIsIncorrect: 'PASSWORD_IS_INCORRECT',
    PasswordIsInvalid: 'PASSWORD_IS_INVALID',
    EmailIsIncorrect: 'EMAIL_IS_INCORRECT',
    IpNew: 'IP_NEW',
    QuestionsAnswersIncorrect: 'QUESTIONS_ANSWERS_INCORRECT',
    QuestionsAnswersInvalid: 'QUESTIONS_ANSWERS_INVALID',
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    SignatureIsIncorrect: 'SIGNATURE_IS_INCORRECT',
    UserLoginAlreadyTaken: 'USER_LOGIN_ALREADY_TAKEN',
    AuthIsNotEnabled: 'AUTH_IS_NOT_ENABLED',
    TokenExpired: 'TOKEN_EXPIRED',
    TooManyReqs: 'TOO_MANY_REQS',
    AuthIsNotConfirmed: 'AUTH_IS_NOT_CONFIRMED',
    NoAuthAvailableForFactor: 'NO_AUTH_AVAILABLE_FOR_FACTOR',
    AuthRequiresAnother: 'AUTH_REQUIRES_ANOTHER',
    CodeIsExpired: 'CODE_IS_EXPIRED',
    CodeTooManyAttempts: 'CODE_TOO_MANY_ATTEMPTS',
    CodeIsIncorrect: 'CODE_IS_INCORRECT',
    Unauthenticated: 'UNAUTHENTICATED',
    ServerErr: 'SERVER_ERR',
    IntegrationErr: 'INTEGRATION_ERR',
    AnyErr: 'ANY_ERR'
} as const;

export type ErrCode = typeof ErrCode[keyof typeof ErrCode];


/**
 * 
 * @export
 * @interface FindSessionsRes
 */
export interface FindSessionsRes {
    /**
     * 
     * @type {Array<Session>}
     * @memberof FindSessionsRes
     */
    'sessions': Array<Session>;
    /**
     * 
     * @type {boolean}
     * @memberof FindSessionsRes
     */
    'tooManySessions'?: boolean;
}
/**
 * 
 * @export
 * @interface HealthRes
 */
export interface HealthRes {
    /**
     * 
     * @type {DbHealthRes}
     * @memberof HealthRes
     */
    'db': DbHealthRes;
    /**
     * 
     * @type {{ [key: string]: HealthStatusRes; }}
     * @memberof HealthRes
     */
    'auth': { [key: string]: HealthStatusRes; };
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthRes
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HealthStatus = {
    Healthy: 'HEALTHY',
    Unavailable: 'UNAVAILABLE',
    Err: 'ERR'
} as const;

export type HealthStatus = typeof HealthStatus[keyof typeof HealthStatus];


/**
 * 
 * @export
 * @interface HealthStatusRes
 */
export interface HealthStatusRes {
    /**
     * 
     * @type {HealthStatus}
     * @memberof HealthStatusRes
     */
    'status': HealthStatus;
    /**
     * 
     * @type {string}
     * @memberof HealthStatusRes
     */
    'msg'?: string;
}
/**
 * Configuration for localization of error messages, emails, etc.
 * @export
 * @interface I18nCfg
 */
export interface I18nCfg {
    /**
     * Directory when messages are stored. To support new language add `<lang>.json5` file. App will create helpful templates after start if dir is not null. 
     * @type {string}
     * @memberof I18nCfg
     */
    'dir'?: string;
    /**
     * Default language to use. 
     * @type {string}
     * @memberof I18nCfg
     */
    'default'?: string;
}
/**
 * 
 * @export
 * @interface InMemoryCfg
 */
export interface InMemoryCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InMemoryCfg
     */
    'inMemory'?: boolean;
}
/**
 * 
 * @export
 * @interface InTokenCfg
 */
export interface InTokenCfg {
    /**
     * 
     * @type {boolean}
     * @memberof InTokenCfg
     */
    'inToken'?: boolean;
}
/**
 * 
 * @export
 * @interface IntegrationErr
 */
export interface IntegrationErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof IntegrationErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof IntegrationErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof IntegrationErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const IntegrationErrCode = {
    NoAuthAvailableForFactor: 'NO_AUTH_AVAILABLE_FOR_FACTOR',
    IntegrationErr: 'INTEGRATION_ERR'
} as const;

export type IntegrationErrCode = typeof IntegrationErrCode[keyof typeof IntegrationErrCode];


/**
 * 
 * @export
 * @interface IpAuthCfg
 */
export interface IpAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof IpAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof IpAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof IpAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof IpAuthCfg
     */
    'burnQuota'?: number;
    /**
     * This allows to drop last bytes of IP. So it allows to authenticate factor when ip has rough match, e.g. the same country, same city, or same internet provider.
     * @type {number}
     * @memberof IpAuthCfg
     */
    'ipBytesToIgnore'?: number;
    /**
     * History of IP addresses user used to sign-in. Authenticated when user attempts to sign in with one of stored IPs.
     * @type {number}
     * @memberof IpAuthCfg
     */
    'historySize'?: number;
}
/**
 * 
 * @export
 * @interface IpAuthRes
 */
export interface IpAuthRes {
    /**
     * 
     * @type {string}
     * @memberof IpAuthRes
     */
    'ipEncoded': string;
}
/**
 * 
 * @export
 * @interface IpNew
 */
export interface IpNew {
    /**
     * 
     * @type {string}
     * @memberof IpNew
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof IpNew
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof IpNew
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface JdbcCfg
 */
export interface JdbcCfg {
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof JdbcCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof JdbcCfg
     */
    'maxConnections'?: number;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Type of login
     * @type {string}
     * @memberof Login
     */
    'type': string;
    /**
     * User unique identifier, email, username, etc.
     * @type {string}
     * @memberof Login
     */
    'login': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'unconfirmedLogin'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Login
     */
    'confirmed'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginId
 */
export interface LoginId {
    /**
     * Type of login
     * @type {string}
     * @memberof LoginId
     */
    'type': string;
    /**
     * User unique identifier, email, username, etc.
     * @type {string}
     * @memberof LoginId
     */
    'login': string;
}
/**
 * 
 * @export
 * @interface MongoCfg
 */
export interface MongoCfg {
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'mongodb': string;
    /**
     * 
     * @type {string}
     * @memberof MongoCfg
     */
    'database': string;
}
/**
 * 
 * @export
 * @interface MysqlCfg
 */
export interface MysqlCfg {
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'mysql'?: string;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof MysqlCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof MysqlCfg
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface NewSessionReq
 */
export interface NewSessionReq {
    /**
     * 
     * @type {string}
     * @memberof NewSessionReq
     */
    'entry': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * Forces specific auth to be used for factor. Takes place only when multiple auths is provided within request and auth can be assigned to several factors. If used in sign-up mode, it just enables those factors. 
     * @type {{ [key: string]: string; }}
     * @memberof NewSessionReq
     */
    'factors'?: { [key: string]: string; };
    /**
     * Request for authenticators 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof NewSessionReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signIn'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'signUp'?: boolean;
    /**
     * Execute only validation ща authenticator requests.
     * @type {boolean}
     * @memberof NewSessionReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface NextFactor
 */
export interface NextFactor {
    /**
     * 
     * @type {string}
     * @memberof NextFactor
     */
    'factor': string;
    /**
     * 
     * @type {Set<string>}
     * @memberof NextFactor
     */
    'supportedAuths': Set<string>;
}
/**
 * 
 * @export
 * @interface NoAuthAvailableForFactor
 */
export interface NoAuthAvailableForFactor {
    /**
     * 
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof NoAuthAvailableForFactor
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface OAuthCfg
 */
export interface OAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof OAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof OAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof OAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof OAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Path for login in id-token or user-info endpoint response. e.g. `res.user.id` extracts user login from `{ \"res\": { \"user\": { \"id\": \"...\" } } }`
     * @type {string}
     * @memberof OAuthCfg
     */
    'extractLogin': string;
    /**
     * Url to get access token by authorisation code.
     * @type {string}
     * @memberof OAuthCfg
     */
    'tokenUrl'?: string;
    /**
     * OAuth client id. Client must be registered on OAuth provider (e.g. facebook, google)
     * @type {string}
     * @memberof OAuthCfg
     */
    'clientId'?: string;
    /**
     * OAuth client secret.
     * @type {string}
     * @memberof OAuthCfg
     */
    'clientSecret'?: string;
    /**
     * If access token provided in request, app tries to extract user id from user-info endpoint.
     * @type {string}
     * @memberof OAuthCfg
     */
    'userInfoUrl'?: string;
    /**
     * Send token in query param.
     * @type {string}
     * @memberof OAuthCfg
     */
    'sendTokenInQuery'?: string;
    /**
     * Send token in Authorisation header.
     * @type {boolean}
     * @memberof OAuthCfg
     */
    'sendTokenInHeader'?: boolean;
    /**
     * Can fill public data by a response of user-info or id-token.
     * @type {{ [key: string]: string; }}
     * @memberof OAuthCfg
     */
    'extractPublicData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface OAuthReq
 */
export interface OAuthReq {
    /**
     * If you have access-token - put it here.
     * @type {string}
     * @memberof OAuthReq
     */
    'accessToken'?: string;
    /**
     * If you have authorisation-code - app will exchange it for access-token.
     * @type {string}
     * @memberof OAuthReq
     */
    'authorizationCode'?: string;
}
/**
 * 
 * @export
 * @interface OAuthRes
 */
export interface OAuthRes {
    /**
     * 
     * @type {string}
     * @memberof OAuthRes
     */
    'login': string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof OAuthRes
     */
    'publicData': { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface OkAuthExecRes
 */
export interface OkAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof OkAuthExecRes
     */
    'status': OkAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof OkAuthExecRes
     */
    'sentCode'?: Code;
    /**
     * 
     * @type {AuthExecResResData}
     * @memberof OkAuthExecRes
     */
    'resData'?: AuthExecResResData;
}

export const OkAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type OkAuthExecResStatusEnum = typeof OkAuthExecResStatusEnum[keyof typeof OkAuthExecResStatusEnum];

/**
 * Password authentication. To enable this auth set auth name to \"password\" or use \"builtin\": \"password\" param.
 * @export
 * @interface PasswordAuthCfg
 */
export interface PasswordAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof PasswordAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof PasswordAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Max allowed Length of the password.
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'maxLength'?: number;
    /**
     * Minimal length of password
     * @type {number}
     * @memberof PasswordAuthCfg
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof PasswordAuthCfg
     */
    'forbidLoginAsPassword'?: boolean;
    /**
     * 
     * @type {PasswordHistoryCfg}
     * @memberof PasswordAuthCfg
     */
    'forbidReusingPassword'?: PasswordHistoryCfg;
    /**
     * Allows to calculate password strength based on mentioned criteria. Requirements will be checked one by one until first failed. 
     * @type {{ [key: string]: PasswordStrengthRequirements; }}
     * @memberof PasswordAuthCfg
     */
    'strength'?: { [key: string]: PasswordStrengthRequirements; };
}
/**
 * 
 * @export
 * @interface PasswordAuthenticateReq
 */
export interface PasswordAuthenticateReq {
    /**
     * User password.
     * @type {string}
     * @memberof PasswordAuthenticateReq
     */
    'password': string;
}
/**
 * Forbids user to change password to the old one. Useful if you force user to change password regularly.
 * @export
 * @interface PasswordHistoryCfg
 */
export interface PasswordHistoryCfg {
    /**
     * Number of current user passwords to store in database.
     * @type {number}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistorySize'?: number;
    /**
     * Lifetime for the password. Accepts time string e.g. 1y, 3m, 2y 6m, etc.
     * @type {string}
     * @memberof PasswordHistoryCfg
     */
    'passwordHistoryTtl'?: string;
}
/**
 * 
 * @export
 * @interface PasswordIsIncorrect
 */
export interface PasswordIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PasswordIsIncorrect
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsIncorrect
     */
    'changedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsIncorrect
     */
    'changedDaysAgo'?: number;
}
/**
 * 
 * @export
 * @interface PasswordIsInvalid
 */
export interface PasswordIsInvalid {
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'msg'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooLong': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'tooShort': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingNumber': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingSymbol': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingUpperCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'missingLowerCase': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'commonPassword': boolean;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsInvalid
     */
    'wasUsedBeforeAt'?: number;
    /**
     * 
     * @type {LoginId}
     * @memberof PasswordIsInvalid
     */
    'matchesLogin'?: LoginId;
    /**
     * 
     * @type {boolean}
     * @memberof PasswordIsInvalid
     */
    'passwordsMismatch': boolean;
    /**
     * 
     * @type {string}
     * @memberof PasswordIsInvalid
     */
    'strength'?: string;
    /**
     * 
     * @type {number}
     * @memberof PasswordIsInvalid
     */
    'wasUsedDaysAgo'?: number;
}
/**
 * Requirements for password
 * @export
 * @interface PasswordStrengthRequirements
 */
export interface PasswordStrengthRequirements {
    /**
     * Minimal length of password
     * @type {number}
     * @memberof PasswordStrengthRequirements
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof PasswordStrengthRequirements
     */
    'forbidLoginAsPassword'?: boolean;
}
/**
 * 
 * @export
 * @interface PasswordUpdateReq
 */
export interface PasswordUpdateReq {
    /**
     * New password to set. If null app generates password automatically.
     * @type {string}
     * @memberof PasswordUpdateReq
     */
    'password'?: string;
    /**
     * Password confirmation. If null app doesn\'t perform this check.
     * @type {string}
     * @memberof PasswordUpdateReq
     */
    'confirmPassword'?: string;
}
/**
 * 
 * @export
 * @interface PasswordUpdateRes
 */
export interface PasswordUpdateRes {
    /**
     * If password was generated by app this field contains generated password.
     * @type {string}
     * @memberof PasswordUpdateRes
     */
    'password': string;
    /**
     * Calculated strength of password. Null means that all checks failed.
     * @type {string}
     * @memberof PasswordUpdateRes
     */
    'strength'?: string;
}
/**
 * 
 * @export
 * @interface PluginClientErr
 */
export interface PluginClientErr {
    /**
     * 
     * @type {string}
     * @memberof PluginClientErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PluginClientErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PluginClientErr
     */
    'msg'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof PluginClientErr
     */
    'data'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface PluginErr
 */
export interface PluginErr {
    /**
     * 
     * @type {string}
     * @memberof PluginErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof PluginErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof PluginErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PostgresCfg
 */
export interface PostgresCfg {
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'postgres'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostgresCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostgresCfg
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersIncorrect
 */
export interface QuestionsAnswersIncorrect {
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof QuestionsAnswersIncorrect
     */
    'msg'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'incorrectAnswers': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersIncorrect
     */
    'requiresMoreAnswers': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionsAnswersIncorrect
     */
    'questionsNotFound': Array<string>;
}
/**
 * 
 * @export
 * @interface QuestionsAnswersInvalid
 */
export interface QuestionsAnswersInvalid {
    /**
     * 
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof QuestionsAnswersInvalid
     */
    'msg'?: string;
    /**
     * 
     * @type {{ [key: string]: AnswerErr; }}
     * @memberof QuestionsAnswersInvalid
     */
    'invalidAnswers': { [key: string]: AnswerErr; };
    /**
     * 
     * @type {boolean}
     * @memberof QuestionsAnswersInvalid
     */
    'tooManyAnswers': boolean;
}
/**
 * 
 * @export
 * @interface QuestionsAuthCfg
 */
export interface QuestionsAuthCfg {
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof QuestionsAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof QuestionsAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Transform user answer to lowercase letters. This allows user still pass a check when he wrote name or city with different cases. `false` means strict match, so \"John\" != \"john\"
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'lowercase'?: boolean;
    /**
     * Remove all non-letters from user answer.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSymbols'?: boolean;
    /**
     * Remove all spaces from user answer.
     * @type {boolean}
     * @memberof QuestionsAuthCfg
     */
    'removeSpaces'?: boolean;
    /**
     * Min length of answer. Length are checked after all answer transformation.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'minLength'?: number;
    /**
     * Max length of answer.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxLength'?: number;
    /**
     * Min number of answers required to pass this check.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'answersRequired'?: number;
    /**
     * Max answers that user can save.
     * @type {number}
     * @memberof QuestionsAuthCfg
     */
    'maxAnswers'?: number;
}
/**
 * 
 * @export
 * @interface QuestionsAuthenticateReq
 */
export interface QuestionsAuthenticateReq {
    /**
     * Given answers for questions. 
     * @type {{ [key: string]: string; }}
     * @memberof QuestionsAuthenticateReq
     */
    'answers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QuestionsAuthenticateRes
 */
export interface QuestionsAuthenticateRes {
    /**
     * Shows is answer was correct. 
     * @type {{ [key: string]: boolean; }}
     * @memberof QuestionsAuthenticateRes
     */
    'correct': { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface QuestionsUpdateReq
 */
export interface QuestionsUpdateReq {
    /**
     * Answers to save. `null` as value removes answer 
     * @type {{ [key: string]: string; }}
     * @memberof QuestionsUpdateReq
     */
    'answers': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface QuestionsUpdateRes
 */
export interface QuestionsUpdateRes {
    /**
     * Date of last update
     * @type {{ [key: string]: number; }}
     * @memberof QuestionsUpdateRes
     */
    'answersSavedAt': { [key: string]: number; };
}
/**
 * Rate limiter configuration
 * @export
 * @interface RateLimiterCfg
 */
export interface RateLimiterCfg {
    /**
     * Create different rate limiters for different users.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'userId'?: boolean;
    /**
     * Create different rate limiters for different ips.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'ip'?: boolean;
    /**
     * Total quota available for time period. Quota means \"weight\" of a request. So quota 1.0 and period 1s allows 10 request with weight 0.1 per seconds or 5 request with weight 0.2 per second.
     * @type {number}
     * @memberof RateLimiterCfg
     */
    'quota'?: number;
    /**
     * Quota restoring period 
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'period'?: string;
    /**
     * Insert delays between requests if there are too many simultaneous requests.
     * @type {boolean}
     * @memberof RateLimiterCfg
     */
    'alignLoad'?: boolean;
    /**
     * Allows to combine rate limiters. Let\'s say rt1 allows 10 reqs per seconds, and rt2 allows 20 reqs per minute. If the rt1 has the rt2 as a parent, that means that rt1 allows 10 reqs per seconds but not more than 20 per minute.
     * @type {string}
     * @memberof RateLimiterCfg
     */
    'parent'?: string;
}
/**
 * 
 * @export
 * @interface RateLimiterReq
 */
export interface RateLimiterReq {
    /**
     * 
     * @type {string}
     * @memberof RateLimiterReq
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof RateLimiterReq
     */
    'quotaToBurn': number;
}
/**
 * 
 * @export
 * @interface RedisCfg
 */
export interface RedisCfg {
    /**
     * 
     * @type {Array<string>}
     * @memberof RedisCfg
     */
    'redis'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'cluster'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'database'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'user'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedisCfg
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RedisCfg
     */
    'ssl'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RedisCfg
     */
    'maxConnections'?: number;
}
/**
 * Long-living token used for generation of new access token. THis is optional. You can set longer access-token lifetime instead.
 * @export
 * @interface RefreshTokenCfg
 */
export interface RefreshTokenCfg {
    /**
     * Lifetime for refresh token. 10d, 3M, etc. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'ttl'?: string;
    /**
     * Refresh token can be prolonged by refresh. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'maxTtl'?: string;
    /**
     * Lifetime of token for unauthenticated session. Limits time that user has to sign in/up, restoring password etc. 
     * @type {string}
     * @memberof RefreshTokenCfg
     */
    'unauthenticatedTtl'?: string;
    /**
     * If false - one refresh token can\'t be used twice. New refresh token will be provided by refresh API.
     * @type {boolean}
     * @memberof RefreshTokenCfg
     */
    'allowReuse'?: boolean;
}
/**
 * 
 * @export
 * @interface RefreshTokenReq
 */
export interface RefreshTokenReq {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenReq
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRes
 */
export interface RefreshTokenRes {
    /**
     * 
     * @type {Tokens}
     * @memberof RefreshTokenRes
     */
    'tokens': Tokens;
    /**
     * 
     * @type {Session}
     * @memberof RefreshTokenRes
     */
    'session': Session;
}
/**
 * Authentication implementation config
 * @export
 * @interface RemoteAuthCfg
 */
export interface RemoteAuthCfg {
    /**
     * Path to the API that implements plugin.
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'remote': string;
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof RemoteAuthCfg
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof RemoteAuthCfg
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof RemoteAuthCfg
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof RemoteAuthCfg
     */
    'burnQuota'?: number;
    /**
     * Add query params after `?` symbol in url. 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'query'?: { [key: string]: string; };
    /**
     * Add headers to request. 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteAuthCfg
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof RemoteAuthCfg
     */
    'code'?: CodeCfg;
}
/**
 * 
 * @export
 * @interface RemoteDbCfg
 */
export interface RemoteDbCfg {
    /**
     * 
     * @type {string}
     * @memberof RemoteDbCfg
     */
    'remote': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'query'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteDbCfg
     */
    'headers'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SHAppCfg
 */
export interface SHAppCfg {
    /**
     * 
     * @type {SHHttpCfg}
     * @memberof SHAppCfg
     */
    'http'?: SHHttpCfg;
    /**
     * Types of logins that can be used for identification.  If the login type is not specified in the auth config - it will be considered a simple login: the user can set any name. E.g. username.  If the login type is specified in the auth config, this login will be generated by the corresponding authenticator. E.g. email, phone or facebook account id.  
     * @type {Set<string>}
     * @memberof SHAppCfg
     */
    'logins'?: Set<string>;
    /**
     * List of auth names and auth configs  To use builtin auths (not a plugin or remote) follow the example: `\"password\": { ... }` or `\"anyAuthName\": { \"builtin\": \"password\", ... }` 
     * @type {{ [key: string]: SHAppCfgAuthsValue; }}
     * @memberof SHAppCfg
     */
    'auths'?: { [key: string]: SHAppCfgAuthsValue; };
    /**
     * List of app entries. Entry usually represents UI used for signing in/up or additional authentication before action. E.g.: - app: main entry that requests user login/email + password and 2fa (if enabled) - api: entry that allows user to generate API keys and connect third-party app - action: additional authentication (e.g. code from sms) requested before e.g. payment 
     * @type {{ [key: string]: EntryCfg; }}
     * @memberof SHAppCfg
     */
    'entries'?: { [key: string]: EntryCfg; };
    /**
     * 
     * @type {DbsCfg}
     * @memberof SHAppCfg
     */
    'db'?: DbsCfg;
    /**
     * 
     * @type {TokenCfg}
     * @memberof SHAppCfg
     */
    'token'?: TokenCfg;
    /**
     * List of rate limiters 
     * @type {{ [key: string]: RateLimiterCfg; }}
     * @memberof SHAppCfg
     */
    'rateLimiters'?: { [key: string]: RateLimiterCfg; };
    /**
     * THe key that app uses for RSA certificate generation used for token signature. If `null` - app will generate secret automatically during startup.
     * @type {string}
     * @memberof SHAppCfg
     */
    'secret'?: string;
    /**
     * Set this key if you want to restrict access to the health-check.
     * @type {string}
     * @memberof SHAppCfg
     */
    'healthCheckKey'?: string;
    /**
     * 
     * @type {I18nCfg}
     * @memberof SHAppCfg
     */
    'i18n'?: I18nCfg;
    /**
     * 
     * @type {string}
     * @memberof SHAppCfg
     */
    '$schema'?: string;
}
/**
 * 
 * @export
 * @interface SHAppCfgAuthsValue
 */
export interface SHAppCfgAuthsValue {
    /**
     * Path to the API that implements plugin.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'remote'?: string;
    /**
     * If this is not null, app forbids to add this auth until listed auth enabled. - if this a string -> require specified auth to be enabled before this. - array of strings -> require any of listed auths to be enabled - array of arrays of strings -> works as `[ [ \"auth1\" and \"auth2\" ] or [ \"auth1\" and \"auth2\" ] ]`
     * @type {Array<Array<string>>}
     * @memberof SHAppCfgAuthsValue
     */
    'requiresAuth'?: Array<Array<string>>;
    /**
     * When this is set to true app will attempt next auth in case of error on current. It\'s works good with IP auth. User can provide both IP auth request and SMS auth request. And SMS will be executed only when IP auth is failed. If set to false any error on this auth will stop the whole request execution.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'skipOnFail'?: boolean;
    /**
     * Apply rate limiter for this auth.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'rateLimiter'?: string;
    /**
     * Every auth execution will burn this amount of quota. Takes place only when rate limiter is specified
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'burnQuota'?: number;
    /**
     * Add query params after `?` symbol in url. 
     * @type {{ [key: string]: string; }}
     * @memberof SHAppCfgAuthsValue
     */
    'query'?: { [key: string]: string; };
    /**
     * Add headers to request. 
     * @type {{ [key: string]: string; }}
     * @memberof SHAppCfgAuthsValue
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {CodeCfg}
     * @memberof SHAppCfgAuthsValue
     */
    'code'?: CodeCfg;
    /**
     * Email server address/IP.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'server'?: string;
    /**
     * Email address of sender.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'sender'?: string;
    /**
     * SMTP username.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'username'?: string;
    /**
     * SMTP password.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'password'?: string;
    /**
     * If not null, server will create template param `confirmationUrl` that will contain query parameters with confirmation code, session id, etc.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'confirmationUrl'?: string;
    /**
     * List of email templates. Key - name of template (can be used lately on frontend), value - path to template. App uses handlebars templates to generate emails. See docs here https://handlebarsjs.com  Email templates received `confirmationUrl`, `action`, `user`, `session`, `codeId`, `code`, `lang`, `headers` as template params, e.g. you can print user id as `{{ user.id }}`.  Template engine also provides `i18n` helper for localisation. E.g. `{{i18n \'confirmationButton\' default=\'Confirm\'}}` searches key `confirmationButton` in files specified by `i18n.dir` config.  It allows setting subject of email using `title` html tag, e.g. `<title>Email subject</title>`.  
     * @type {{ [key: string]: string; }}
     * @memberof SHAppCfgAuthsValue
     */
    'templates'?: { [key: string]: string; };
    /**
     * Additional params for template. 
     * @type {{ [key: string]: string; }}
     * @memberof SHAppCfgAuthsValue
     */
    'templateParams'?: { [key: string]: string; };
    /**
     * This allows to drop last bytes of IP. So it allows to authenticate factor when ip has rough match, e.g. the same country, same city, or same internet provider.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'ipBytesToIgnore'?: number;
    /**
     * History of IP addresses user used to sign-in. Authenticated when user attempts to sign in with one of stored IPs.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'historySize'?: number;
    /**
     * Path for login in id-token or user-info endpoint response. e.g. `res.user.id` extracts user login from `{ \"res\": { \"user\": { \"id\": \"...\" } } }`
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'extractLogin'?: string;
    /**
     * Url to get access token by authorisation code.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'tokenUrl'?: string;
    /**
     * OAuth client id. Client must be registered on OAuth provider (e.g. facebook, google)
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'clientId'?: string;
    /**
     * OAuth client secret.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'clientSecret'?: string;
    /**
     * If access token provided in request, app tries to extract user id from user-info endpoint.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'userInfoUrl'?: string;
    /**
     * Send token in query param.
     * @type {string}
     * @memberof SHAppCfgAuthsValue
     */
    'sendTokenInQuery'?: string;
    /**
     * Send token in Authorisation header.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'sendTokenInHeader'?: boolean;
    /**
     * Can fill public data by a response of user-info or id-token.
     * @type {{ [key: string]: string; }}
     * @memberof SHAppCfgAuthsValue
     */
    'extractPublicData'?: { [key: string]: string; };
    /**
     * Max length of answer.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'maxLength'?: number;
    /**
     * Min length of answer. Length are checked after all answer transformation.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'minLength'?: number;
    /**
     * Require password to contain at least one digit.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'requireNumber'?: boolean;
    /**
     * Require password to contain at least one symbol e.g. @, !, &...
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'requireSymbol'?: boolean;
    /**
     * This requires password to contain both lowercase and uppercase letters.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'requireUpperCase'?: boolean;
    /**
     * Password will be checked against table 1,000,000 of most overused passwords.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'forbidCommonPasswords'?: boolean;
    /**
     * Rejects passwords that match username, email, anything that used as a login according to logins config.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'forbidLoginAsPassword'?: boolean;
    /**
     * 
     * @type {PasswordHistoryCfg}
     * @memberof SHAppCfgAuthsValue
     */
    'forbidReusingPassword'?: PasswordHistoryCfg;
    /**
     * Allows to calculate password strength based on mentioned criteria. Requirements will be checked one by one until first failed. 
     * @type {{ [key: string]: PasswordStrengthRequirements; }}
     * @memberof SHAppCfgAuthsValue
     */
    'strength'?: { [key: string]: PasswordStrengthRequirements; };
    /**
     * Transform user answer to lowercase letters. This allows user still pass a check when he wrote name or city with different cases. `false` means strict match, so \"John\" != \"john\"
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'lowercase'?: boolean;
    /**
     * Remove all non-letters from user answer.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'removeSymbols'?: boolean;
    /**
     * Remove all spaces from user answer.
     * @type {boolean}
     * @memberof SHAppCfgAuthsValue
     */
    'removeSpaces'?: boolean;
    /**
     * Min number of answers required to pass this check.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'answersRequired'?: number;
    /**
     * Max answers that user can save.
     * @type {number}
     * @memberof SHAppCfgAuthsValue
     */
    'maxAnswers'?: number;
}
/**
 * Http server config
 * @export
 * @interface SHHttpCfg
 */
export interface SHHttpCfg {
    /**
     * A port that the server will use to accept http requests 
     * @type {number}
     * @memberof SHHttpCfg
     */
    'port'?: number;
    /**
     * IP address to bind to. Usually 0.0.0.0 to accept for any connection or 127.0.0.1 to accept only localhost 
     * @type {string}
     * @memberof SHHttpCfg
     */
    'bind'?: string;
    /**
     * If true, X-Forwarded-For header is used to get client\'s IP address
     * @type {boolean}
     * @memberof SHHttpCfg
     */
    'proxy'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveUserReq
 */
export interface SaveUserReq {
    /**
     * Optional factors to enable/disable. If factor marked as required in config, it will be considered enabled by default and this request doesn\'t change this. 
     * @type {{ [key: string]: boolean; }}
     * @memberof SaveUserReq
     */
    'factors'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SaveUserReq
     */
    'logins'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: AuthenticateReqAuthReqsValue; }}
     * @memberof SaveUserReq
     */
    'authReqs'?: { [key: string]: AuthenticateReqAuthReqsValue; };
    /**
     * 
     * @type {boolean}
     * @memberof SaveUserReq
     */
    'dryRun'?: boolean;
}
/**
 * 
 * @export
 * @interface SaveUserRes
 */
export interface SaveUserRes {
    /**
     * 
     * @type {User}
     * @memberof SaveUserRes
     */
    'user'?: User;
    /**
     * 
     * @type {{ [key: string]: AuthExecRes; }}
     * @memberof SaveUserRes
     */
    'authRes': { [key: string]: AuthExecRes; };
}
/**
 * 
 * @export
 * @interface ServerErr
 */
export interface ServerErr {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ServerErr
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof ServerErr
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof ServerErr
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ServerErrCode = {
    ServerErr: 'SERVER_ERR',
    PluginErr: 'PLUGIN_ERR'
} as const;

export type ServerErrCode = typeof ServerErrCode[keyof typeof ServerErrCode];


/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'id': string;
    /**
     * Entry that authenticates this session
     * @type {string}
     * @memberof Session
     */
    'entry': string;
    /**
     * Login used to identify this user
     * @type {Array<LoginId>}
     * @memberof Session
     */
    'identifiedBy': Array<LoginId>;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userId'?: string;
    /**
     * Authenticator used for factors 
     * @type {{ [key: string]: string; }}
     * @memberof Session
     */
    'authenticatedBy': { [key: string]: string; };
    /**
     * Auths that waiting for confirmation 
     * @type {{ [key: string]: UnconfirmedAuth; }}
     * @memberof Session
     */
    'unconfirmedAuths': { [key: string]: UnconfirmedAuth; };
    /**
     * List of factors needed to authenticate this session
     * @type {Array<NextFactor>}
     * @memberof Session
     */
    'nextFactors': Array<NextFactor>;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'signedInAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'expiresAt': number;
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'refreshedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'newUser': boolean;
    /**
     * 
     * @type {Device}
     * @memberof Session
     */
    'device': Device;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'systemAccess': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'expired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Session
     */
    'authenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface SessionExpired
 */
export interface SessionExpired {
    /**
     * 
     * @type {string}
     * @memberof SessionExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof SessionExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof SessionExpired
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SignatureIsIncorrect
 */
export interface SignatureIsIncorrect {
    /**
     * 
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof SignatureIsIncorrect
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SkippedAuthExecRes
 */
export interface SkippedAuthExecRes {
    /**
     * 
     * @type {string}
     * @memberof SkippedAuthExecRes
     */
    'status': SkippedAuthExecResStatusEnum;
    /**
     * 
     * @type {Code}
     * @memberof SkippedAuthExecRes
     */
    'sentCode'?: Code;
}

export const SkippedAuthExecResStatusEnum = {
    Ok: 'OK',
    Err: 'ERR',
    Skipped: 'SKIPPED'
} as const;

export type SkippedAuthExecResStatusEnum = typeof SkippedAuthExecResStatusEnum[keyof typeof SkippedAuthExecResStatusEnum];

/**
 * 
 * @export
 * @interface SqliteCfg
 */
export interface SqliteCfg {
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof SqliteCfg
     */
    'maxConnections'?: number;
    /**
     * 
     * @type {string}
     * @memberof SqliteCfg
     */
    'sqlite'?: string;
}
/**
 * Token lifetime config.
 * @export
 * @interface TokenCfg
 */
export interface TokenCfg {
    /**
     * 
     * @type {AccessTokenCfg}
     * @memberof TokenCfg
     */
    'access'?: AccessTokenCfg;
    /**
     * 
     * @type {RefreshTokenCfg}
     * @memberof TokenCfg
     */
    'refresh'?: RefreshTokenCfg;
    /**
     * Require all request to be made from the same device.
     * @type {boolean}
     * @memberof TokenCfg
     */
    'sameUserAgent'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenExpired
 */
export interface TokenExpired {
    /**
     * 
     * @type {string}
     * @memberof TokenExpired
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof TokenExpired
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof TokenExpired
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenExpired
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @interface TokenHandlerCfg
 */
export interface TokenHandlerCfg {
    /**
     * If access token provided in request, app tries to extract user id from user-info endpoint.
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'userInfoUrl': string;
    /**
     * Send token in query param.
     * @type {string}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInQuery'?: string;
    /**
     * Send token in Authorisation header.
     * @type {boolean}
     * @memberof TokenHandlerCfg
     */
    'sendTokenInHeader'?: boolean;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * 
     * @type {string}
     * @memberof Tokens
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof Tokens
     */
    'refresh': string;
    /**
     * 
     * @type {number}
     * @memberof Tokens
     */
    'accessTokenExpiresAt'?: number;
}
/**
 * 
 * @export
 * @interface TooManyReqs
 */
export interface TooManyReqs {
    /**
     * 
     * @type {string}
     * @memberof TooManyReqs
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof TooManyReqs
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof TooManyReqs
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeSeconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof TooManyReqs
     */
    'waitTimeMinutes'?: number;
}
/**
 * 
 * @export
 * @interface Unauthenticated
 */
export interface Unauthenticated {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof Unauthenticated
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof Unauthenticated
     */
    'msg'?: string;
    /**
     * 
     * @type {number}
     * @memberof Unauthenticated
     */
    'expiredAt'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UnauthenticatedCode = {
    SessionExpired: 'SESSION_EXPIRED',
    AccessDenied: 'ACCESS_DENIED',
    UserNotFound: 'USER_NOT_FOUND',
    TokenExpired: 'TOKEN_EXPIRED',
    Unauthenticated: 'UNAUTHENTICATED'
} as const;

export type UnauthenticatedCode = typeof UnauthenticatedCode[keyof typeof UnauthenticatedCode];


/**
 * 
 * @export
 * @interface UnconfirmedAuth
 */
export interface UnconfirmedAuth {
    /**
     * 
     * @type {Array<CodeVerifier>}
     * @memberof UnconfirmedAuth
     */
    'sentCodes'?: Array<CodeVerifier>;
}
/**
 * 
 * @export
 * @interface UnconfirmedAuthData
 */
export interface UnconfirmedAuthData {
    /**
     * 
     * @type {AuthData}
     * @memberof UnconfirmedAuthData
     */
    'data': AuthData;
    /**
     * 
     * @type {CodeVerifier}
     * @memberof UnconfirmedAuthData
     */
    'code': CodeVerifier;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Generated user uuid 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {Array<Login>}
     * @memberof User
     */
    'logins': Array<Login>;
    /**
     * Public data of confirmed auths and sent codes for unconfirmed auths. 
     * @type {{ [key: string]: AuthUserCfg; }}
     * @memberof User
     */
    'auths': { [key: string]: AuthUserCfg; };
    /**
     * Enabled factors
     * @type {Set<string>}
     * @memberof User
     */
    'factors': Set<string>;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'signedUpAt': number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'updatedAt': number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isNew'?: boolean;
    /**
     * Allows to access to any user in the app.
     * @type {boolean}
     * @memberof User
     */
    'systemAccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'new'?: boolean;
}
/**
 * 
 * @export
 * @interface UserLoginAlreadyTaken
 */
export interface UserLoginAlreadyTaken {
    /**
     * 
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof UserLoginAlreadyTaken
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface UserNotFound
 */
export interface UserNotFound {
    /**
     * 
     * @type {string}
     * @memberof UserNotFound
     */
    'code': string;
    /**
     * Message for developers.
     * @type {string}
     * @memberof UserNotFound
     */
    'devMsg': string;
    /**
     * Localised message suitable for UI.
     * @type {string}
     * @memberof UserNotFound
     */
    'msg'?: string;
}

/**
 * AuthorisationApi - axios parameter creator
 * @export
 */
export const AuthorisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (authorizeReq: AuthorizeReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizeReq' is not null or undefined
            assertParamExists('authorize', 'authorizeReq', authorizeReq)
            const localVarPath = `/api/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizeReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit: async (rateLimiterReq: RateLimiterReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rateLimiterReq' is not null or undefined
            assertParamExists('limit', 'rateLimiterReq', rateLimiterReq)
            const localVarPath = `/api/rate-limiter/limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateLimiterReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorisationApi - functional programming interface
 * @export
 */
export const AuthorisationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorisationApiAxiosParamCreator(configuration)
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(authorizeReq: AuthorizeReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(authorizeReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limit(rateLimiterReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorisationApi - factory interface
 * @export
 */
export const AuthorisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorisationApiFp(configuration)
    return {
        /**
         * Validates token and executes rate limiter. This API should be called by backend. 
         * @param {AuthorizeReq} authorizeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(authorizeReq: AuthorizeReq, options?: any): AxiosPromise<AuthorizeRes> {
            return localVarFp.authorize(authorizeReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
         * @param {RateLimiterReq} rateLimiterReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limit(rateLimiterReq: RateLimiterReq, options?: any): AxiosPromise<AuthorizeRes> {
            return localVarFp.limit(rateLimiterReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorisationApi - object-oriented interface
 * @export
 * @class AuthorisationApi
 * @extends {BaseAPI}
 */
export class AuthorisationApi extends BaseAPI {
    /**
     * Validates token and executes rate limiter. This API should be called by backend. 
     * @param {AuthorizeReq} authorizeReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public authorize(authorizeReq: AuthorizeReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).authorize(authorizeReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Executes rate limiter if no authorisation is required. Otherwise, this works similarly to /authorise. 
     * @param {RateLimiterReq} rateLimiterReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorisationApi
     */
    public limit(rateLimiterReq: RateLimiterReq, options?: AxiosRequestConfig) {
        return AuthorisationApiFp(this.configuration).limit(rateLimiterReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/cfg`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get server plugins state
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (key?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/server/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cfg(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SHAppCfg>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cfg(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get server plugins state
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(key?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Current server configuration. Available only for users with system-access. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cfg(options?: any): AxiosPromise<SHAppCfg> {
            return localVarFp.cfg(options).then((request) => request(axios, basePath));
        },
        /**
         * Get server plugins state
         * @param {string} [key] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(key?: string, options?: any): AxiosPromise<HealthRes> {
            return localVarFp.health(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Current server configuration. Available only for users with system-access. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public cfg(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).cfg(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get server plugins state
     * @param {string} [key] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public health(key?: string, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).health(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticateReq: AuthenticateReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateReq' is not null or undefined
            assertParamExists('authenticate', 'authenticateReq', authenticateReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths: async (confirmSessionAuthsReq: ConfirmSessionAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmSessionAuthsReq' is not null or undefined
            assertParamExists('confirmSessionAuths', 'confirmSessionAuthsReq', confirmSessionAuthsReq)
            const localVarPath = `/api/session/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmSessionAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delSession: async (sessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('delSession', 'sessionId', sessionId)
            const localVarPath = `/api/session/{session-id}`
                .replace(`{${"session-id"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (entry?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (entry !== undefined) {
                localVarQueryParameter['entry'] = entry;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current session data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession: async (newSessionReq: NewSessionReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newSessionReq' is not null or undefined
            assertParamExists('newSession', 'newSessionReq', newSessionReq)
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newSessionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticateReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmSessionAuths(confirmSessionAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delSession(sessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delSession(sessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(entry?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSessionsRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(entry, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get current session data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticateRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newSession(newSessionReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signOut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticateReq} authenticateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticateReq: AuthenticateReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.authenticate(authenticateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
         * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delSession(sessionId: string, options?: any): AxiosPromise<object> {
            return localVarFp.delSession(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [entry] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(entry?: string, userId?: string, options?: any): AxiosPromise<FindSessionsRes> {
            return localVarFp.getAll(entry, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current session data. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(options?: any): AxiosPromise<Session> {
            return localVarFp.getSession(options).then((request) => request(axios, basePath));
        },
        /**
         * Create new session. if session entry requires another entry, access token must be provided. 
         * @param {NewSessionReq} newSessionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newSession(newSessionReq: NewSessionReq, options?: any): AxiosPromise<AuthenticateRes> {
            return localVarFp.newSession(newSessionReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signOut(options?: any): AxiosPromise<object> {
            return localVarFp.signOut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticateReq} authenticateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public authenticate(authenticateReq: AuthenticateReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).authenticate(authenticateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm auth with received code. To get code id, check response of sign in / sign up / authenticate API. 
     * @param {ConfirmSessionAuthsReq} confirmSessionAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public confirmSessionAuths(confirmSessionAuthsReq: ConfirmSessionAuthsReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).confirmSessionAuths(confirmSessionAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public delSession(sessionId: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).delSession(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [entry] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAll(entry?: string, userId?: string, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getAll(entry, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current session data. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSession(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).getSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new session. if session entry requires another entry, access token must be provided. 
     * @param {NewSessionReq} newSessionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public newSession(newSessionReq: NewSessionReq, options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).newSession(newSessionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public signOut(options?: AxiosRequestConfig) {
        return SessionApiFp(this.configuration).signOut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SignatureApi - axios parameter creator
 * @export
 */
export const SignatureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public key generated from app-secret from config used for signature validation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/signature/public-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sign data using specified secret. 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign: async (body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sign', 'body', body)
            const localVarPath = `/api/signature/sign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates data signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (signature: string, body: string, secret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signature' is not null or undefined
            assertParamExists('verify', 'signature', signature)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('verify', 'body', body)
            const localVarPath = `/api/signature/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signature !== undefined) {
                localVarQueryParameter['signature'] = signature;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignatureApi - functional programming interface
 * @export
 */
export const SignatureApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignatureApiAxiosParamCreator(configuration)
    return {
        /**
         * Public key generated from app-secret from config used for signature validation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sign data using specified secret. 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sign(body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sign(body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates data signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(signature, body, secret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SignatureApi - factory interface
 * @export
 */
export const SignatureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignatureApiFp(configuration)
    return {
        /**
         * Public key generated from app-secret from config used for signature validation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicKey(options?: any): AxiosPromise<string> {
            return localVarFp.getPublicKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Sign data using specified secret. 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sign(body: string, secret?: string, options?: any): AxiosPromise<string> {
            return localVarFp.sign(body, secret, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates data signature
         * @param {string} signature 
         * @param {string} body 
         * @param {string} [secret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(signature: string, body: string, secret?: string, options?: any): AxiosPromise<void> {
            return localVarFp.verify(signature, body, secret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignatureApi - object-oriented interface
 * @export
 * @class SignatureApi
 * @extends {BaseAPI}
 */
export class SignatureApi extends BaseAPI {
    /**
     * Public key generated from app-secret from config used for signature validation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public getPublicKey(options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).getPublicKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sign data using specified secret. 
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public sign(body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).sign(body, secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates data signature
     * @param {string} signature 
     * @param {string} body 
     * @param {string} [secret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignatureApi
     */
    public verify(signature: string, body: string, secret?: string, options?: AxiosRequestConfig) {
        return SignatureApiFp(this.configuration).verify(signature, body, secret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get new access token using refresh token.
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenReq: RefreshTokenReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenReq' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenReq', refreshTokenReq)
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Get new access token using refresh token.
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Get new access token using refresh token.
         * @param {RefreshTokenReq} refreshTokenReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenReq: RefreshTokenReq, options?: any): AxiosPromise<RefreshTokenRes> {
            return localVarFp.refreshToken(refreshTokenReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Get new access token using refresh token.
     * @param {RefreshTokenReq} refreshTokenReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public refreshToken(refreshTokenReq: RefreshTokenReq, options?: AxiosRequestConfig) {
        return TokenApiFp(this.configuration).refreshToken(refreshTokenReq, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths: async (confirmUserAuthsReq: ConfirmUserAuthsReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmUserAuthsReq' is not null or undefined
            assertParamExists('confirmUserAuths', 'confirmUserAuthsReq', confirmUserAuthsReq)
            const localVarPath = `/api/user/auth/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmUserAuthsReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser: async (id: string, editUserReq: EditUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('editUser', 'id', id)
            // verify required parameter 'editUserReq' is not null or undefined
            assertParamExists('editUser', 'editUserReq', editUserReq)
            const localVarPath = `/api/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser: async (saveUserReq: SaveUserReq, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveUserReq' is not null or undefined
            assertParamExists('saveUser', 'saveUserReq', saveUserReq)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveUserReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmUserAuths(confirmUserAuthsReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editUser(id, editUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveUserRes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUser(saveUserReq, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {EditUserReq} editUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUser(id: string, editUserReq: EditUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.editUser(id, editUserReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveUserReq} saveUserReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUser(saveUserReq: SaveUserReq, options?: any): AxiosPromise<SaveUserRes> {
            return localVarFp.saveUser(saveUserReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {ConfirmUserAuthsReq} confirmUserAuthsReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public confirmUserAuths(confirmUserAuthsReq: ConfirmUserAuthsReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).confirmUserAuths(confirmUserAuthsReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {EditUserReq} editUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public editUser(id: string, editUserReq: EditUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).editUser(id, editUserReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveUserReq} saveUserReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public saveUser(saveUserReq: SaveUserReq, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).saveUser(saveUserReq, options).then((request) => request(this.axios, this.basePath));
    }
}


